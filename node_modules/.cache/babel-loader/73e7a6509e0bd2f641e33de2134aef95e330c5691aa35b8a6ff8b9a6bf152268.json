{"ast":null,"code":"import { msalInstance } from '../auth/AuthProvider';\nimport { protectedResources } from '../auth/authConfig';\n\n// Base URL for API requests\nconst API_BASE_URL = protectedResources.timeSheetApi.endpoint;\n\n// Token cache to avoid excessive requests\nlet tokenCache = null;\n\n// Get the authentication token\nconst getToken = async () => {\n  try {\n    // Check if we have a valid cached token\n    if (tokenCache && tokenCache.expiresAt > Date.now()) {\n      console.log(\"Using cached token\");\n      return tokenCache.token;\n    }\n    const account = msalInstance.getActiveAccount();\n    if (!account) {\n      console.warn('No active account! Proceeding without authentication token.');\n      return null;\n    }\n    try {\n      const tokenResponse = await msalInstance.acquireTokenSilent({\n        scopes: protectedResources.timeSheetApi.scopes,\n        account: account\n      });\n\n      // Cache the token with expiration (subtract 5 minutes for safety)\n      const expiresInMs = tokenResponse.expiresOn ? tokenResponse.expiresOn.getTime() - Date.now() - 5 * 60 * 1000 : 3600 * 1000; // Default to 1 hour if no expiration\n\n      tokenCache = {\n        token: tokenResponse.accessToken,\n        expiresAt: Date.now() + expiresInMs\n      };\n      return tokenResponse.accessToken;\n    } catch (tokenError) {\n      console.warn('Failed to get token, proceeding with unauthenticated request:', tokenError);\n      return null;\n    }\n  } catch (error) {\n    console.error('Failed to get token:', error);\n    return null;\n  }\n};\n\n// Get authenticated headers\nconst getAuthHeaders = async () => {\n  const token = await getToken();\n  const headers = {\n    'Content-Type': 'application/json'\n  };\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`;\n  }\n  return headers;\n};\n\n// Get timesheets for the current user\nexport async function getTimesheets(userInfo) {\n  try {\n    const headers = await getAuthHeaders();\n\n    // Create an AbortController with a timeout\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/timesheets?userId=${userInfo.userId}`, {\n        headers,\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      if (!response.ok) {\n        throw new Error(`Error fetching timesheets: ${response.statusText}`);\n      }\n      const data = await response.json();\n      return data.timesheets || [];\n    } catch (fetchError) {\n      if (fetchError.name === 'AbortError') {\n        console.warn('Fetch request timed out after 10 seconds');\n        return []; // Return empty array on timeout\n      }\n      throw fetchError;\n    }\n  } catch (error) {\n    console.error('Failed to fetch timesheets:', error);\n    // Return empty array instead of throwing to prevent cascade of errors\n    return [];\n  }\n}\n\n// Save a timesheet with user information\nexport async function saveTimesheet(timesheet, userInfo) {\n  try {\n    const headers = await getAuthHeaders();\n\n    // Ensure user information is included in the timesheet\n    const timesheetWithUser = {\n      ...timesheet,\n      userId: userInfo.userId,\n      userEmail: userInfo.email,\n      userName: userInfo.name,\n      updatedAt: new Date().toISOString()\n    };\n    const response = await fetch(`${API_BASE_URL}/timesheets`, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(timesheetWithUser)\n    });\n    if (!response.ok) {\n      throw new Error(`Error saving timesheet: ${response.statusText}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Failed to save timesheet:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["msalInstance","protectedResources","API_BASE_URL","timeSheetApi","endpoint","tokenCache","getToken","expiresAt","Date","now","console","log","token","account","getActiveAccount","warn","tokenResponse","acquireTokenSilent","scopes","expiresInMs","expiresOn","getTime","accessToken","tokenError","error","getAuthHeaders","headers","getTimesheets","userInfo","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","userId","signal","clearTimeout","ok","Error","statusText","data","json","timesheets","fetchError","name","saveTimesheet","timesheet","timesheetWithUser","userEmail","email","userName","updatedAt","toISOString","method","body","JSON","stringify"],"sources":["/Users/theo/Documents/GitHub/weekly-time-allocation/src/services/timesheetService.ts"],"sourcesContent":["import { TimeSheet, UserInfo } from '../models/types';\nimport { msalInstance } from '../auth/AuthProvider';\nimport { protectedResources } from '../auth/authConfig';\n\n// Base URL for API requests\nconst API_BASE_URL = protectedResources.timeSheetApi.endpoint;\n\n// Token cache to avoid excessive requests\nlet tokenCache: {\n  token: string;\n  expiresAt: number;\n} | null = null;\n\n// Get the authentication token\nconst getToken = async (): Promise<string | null> => {\n  try {\n    // Check if we have a valid cached token\n    if (tokenCache && tokenCache.expiresAt > Date.now()) {\n      console.log(\"Using cached token\");\n      return tokenCache.token;\n    }\n\n    const account = msalInstance.getActiveAccount();\n    if (!account) {\n      console.warn('No active account! Proceeding without authentication token.');\n      return null;\n    }\n    \n    try {\n      const tokenResponse = await msalInstance.acquireTokenSilent({\n        scopes: protectedResources.timeSheetApi.scopes,\n        account: account\n      });\n      \n      // Cache the token with expiration (subtract 5 minutes for safety)\n      const expiresInMs = tokenResponse.expiresOn ? \n        (tokenResponse.expiresOn.getTime() - Date.now() - 5 * 60 * 1000) : \n        (3600 * 1000); // Default to 1 hour if no expiration\n\n      tokenCache = {\n        token: tokenResponse.accessToken,\n        expiresAt: Date.now() + expiresInMs\n      };\n      \n      return tokenResponse.accessToken;\n    } catch (tokenError) {\n      console.warn('Failed to get token, proceeding with unauthenticated request:', tokenError);\n      return null;\n    }\n  } catch (error) {\n    console.error('Failed to get token:', error);\n    return null;\n  }\n};\n\n// Get authenticated headers\nconst getAuthHeaders = async (): Promise<HeadersInit> => {\n  const token = await getToken();\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json'\n  };\n  \n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`;\n  }\n  \n  return headers;\n};\n\n// Get timesheets for the current user\nexport async function getTimesheets(userInfo: UserInfo): Promise<TimeSheet[]> {\n  try {\n    const headers = await getAuthHeaders();\n    \n    // Create an AbortController with a timeout\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n    \n    try {\n      const response = await fetch(`${API_BASE_URL}/timesheets?userId=${userInfo.userId}`, {\n        headers,\n        signal: controller.signal\n      });\n      \n      clearTimeout(timeoutId);\n      \n      if (!response.ok) {\n        throw new Error(`Error fetching timesheets: ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      return data.timesheets || [];\n    } catch (fetchError: any) {\n      if (fetchError.name === 'AbortError') {\n        console.warn('Fetch request timed out after 10 seconds');\n        return []; // Return empty array on timeout\n      }\n      throw fetchError;\n    }\n  } catch (error) {\n    console.error('Failed to fetch timesheets:', error);\n    // Return empty array instead of throwing to prevent cascade of errors\n    return [];\n  }\n}\n\n// Save a timesheet with user information\nexport async function saveTimesheet(timesheet: TimeSheet, userInfo: UserInfo): Promise<{ id: string, message: string }> {\n  try {\n    const headers = await getAuthHeaders();\n    \n    // Ensure user information is included in the timesheet\n    const timesheetWithUser = {\n      ...timesheet,\n      userId: userInfo.userId,\n      userEmail: userInfo.email,\n      userName: userInfo.name,\n      updatedAt: new Date().toISOString()\n    };\n    \n    const response = await fetch(`${API_BASE_URL}/timesheets`, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(timesheetWithUser)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Error saving timesheet: ${response.statusText}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Failed to save timesheet:', error);\n    throw error;\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}