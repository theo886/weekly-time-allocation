{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { PerformanceEvents, StringUtils, Constants, UrlString } from '@azure/msal-common';\nimport { InteractionHandler } from './InteractionHandler.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { DEFAULT_IFRAME_TIMEOUT_MS } from '../config/Configuration.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar SilentHandler = /** @class */function (_super) {\n  __extends(SilentHandler, _super);\n  function SilentHandler(authCodeModule, storageImpl, authCodeRequest, logger, systemOptions, performanceClient) {\n    var _this = _super.call(this, authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) || this;\n    _this.navigateFrameWait = systemOptions.navigateFrameWait;\n    _this.pollIntervalMilliseconds = systemOptions.pollIntervalMilliseconds;\n    return _this;\n  }\n  /**\r\n   * Creates a hidden iframe to given URL using user-requested scopes as an id.\r\n   * @param urlNavigate\r\n   * @param userRequestScopes\r\n   */\n  SilentHandler.prototype.initiateAuthRequest = function (requestUrl) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, this.authCodeRequest.correlationId);\n            if (StringUtils.isEmpty(requestUrl)) {\n              // Throw error if request URL is empty.\n              this.logger.info(\"Navigate url is empty\");\n              throw BrowserAuthError.createEmptyNavigationUriError();\n            }\n            if (!this.navigateFrameWait) return [3 /*break*/, 2];\n            this.performanceClient.setPreQueueTime(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId);\n            return [4 /*yield*/, this.loadFrame(requestUrl)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n          case 2:\n            return [2 /*return*/, this.loadFrameSync(requestUrl)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\r\n   * @param iframe\r\n   * @param timeout\r\n   */\n  SilentHandler.prototype.monitorIframeForHash = function (iframe, timeout) {\n    var _this = this;\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, this.authCodeRequest.correlationId);\n    return new Promise(function (resolve, reject) {\n      if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n        _this.logger.warning(\"system.loadFrameTimeout or system.iframeHashTimeout set to lower (\" + timeout + \"ms) than the default (\" + DEFAULT_IFRAME_TIMEOUT_MS + \"ms). This may result in timeouts.\");\n      }\n      /*\r\n       * Polling for iframes can be purely timing based,\r\n       * since we don't need to account for interaction.\r\n       */\n      var nowMark = window.performance.now();\n      var timeoutMark = nowMark + timeout;\n      var intervalId = setInterval(function () {\n        if (window.performance.now() > timeoutMark) {\n          _this.removeHiddenIframe(iframe);\n          clearInterval(intervalId);\n          reject(BrowserAuthError.createMonitorIframeTimeoutError());\n          return;\n        }\n        var href = Constants.EMPTY_STRING;\n        var contentWindow = iframe.contentWindow;\n        try {\n          /*\r\n           * Will throw if cross origin,\r\n           * which should be caught and ignored\r\n           * since we need the interval to keep running while on STS UI.\r\n           */\n          href = contentWindow ? contentWindow.location.href : Constants.EMPTY_STRING;\n        } catch (e) {}\n        if (StringUtils.isEmpty(href)) {\n          return;\n        }\n        var contentHash = contentWindow ? contentWindow.location.hash : Constants.EMPTY_STRING;\n        if (UrlString.hashContainsKnownProperties(contentHash)) {\n          // Success case\n          _this.removeHiddenIframe(iframe);\n          clearInterval(intervalId);\n          resolve(contentHash);\n          return;\n        }\n      }, _this.pollIntervalMilliseconds);\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Loads iframe with authorization endpoint URL\r\n   * @ignore\r\n   */\n  SilentHandler.prototype.loadFrame = function (urlNavigate) {\n    var _this = this;\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId);\n    /*\r\n     * This trick overcomes iframe navigation in IE\r\n     * IE does not load the page consistently in iframe\r\n     */\n    return new Promise(function (resolve, reject) {\n      var frameHandle = _this.createHiddenIframe();\n      setTimeout(function () {\n        if (!frameHandle) {\n          reject(\"Unable to load iframe\");\n          return;\n        }\n        frameHandle.src = urlNavigate;\n        resolve(frameHandle);\n      }, _this.navigateFrameWait);\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\r\n   * @param urlNavigate\r\n   * @param frameName\r\n   * @param logger\r\n   */\n  SilentHandler.prototype.loadFrameSync = function (urlNavigate) {\n    var frameHandle = this.createHiddenIframe();\n    frameHandle.src = urlNavigate;\n    return frameHandle;\n  };\n  /**\r\n   * @hidden\r\n   * Creates a new hidden iframe or gets an existing one for silent token renewal.\r\n   * @ignore\r\n   */\n  SilentHandler.prototype.createHiddenIframe = function () {\n    var authFrame = document.createElement(\"iframe\");\n    authFrame.className = \"msalSilentIframe\";\n    authFrame.style.visibility = \"hidden\";\n    authFrame.style.position = \"absolute\";\n    authFrame.style.width = authFrame.style.height = \"0\";\n    authFrame.style.border = \"0\";\n    authFrame.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n    document.getElementsByTagName(\"body\")[0].appendChild(authFrame);\n    return authFrame;\n  };\n  /**\r\n   * @hidden\r\n   * Removes a hidden iframe from the page.\r\n   * @ignore\r\n   */\n  SilentHandler.prototype.removeHiddenIframe = function (iframe) {\n    if (document.body === iframe.parentNode) {\n      document.body.removeChild(iframe);\n    }\n  };\n  return SilentHandler;\n}(InteractionHandler);\nexport { SilentHandler };\n//# sourceMappingURL=SilentHandler.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}