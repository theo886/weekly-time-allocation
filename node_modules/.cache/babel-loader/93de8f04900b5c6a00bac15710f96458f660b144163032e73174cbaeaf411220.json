{"ast":null,"code":"/*! @azure/msal-common v13.3.3 2024-06-06 */\n'use strict';\n\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { AADAuthorityConstants, Constants } from '../utils/Constants.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Url object class which can perform various transformations on url strings.\r\n */\nvar UrlString = /** @class */function () {\n  function UrlString(url) {\n    this._urlString = url;\n    if (StringUtils.isEmpty(this._urlString)) {\n      // Throws error if url is empty\n      throw ClientConfigurationError.createUrlEmptyError();\n    }\n    if (StringUtils.isEmpty(this.getHash())) {\n      this._urlString = UrlString.canonicalizeUri(url);\n    }\n  }\n  Object.defineProperty(UrlString.prototype, \"urlString\", {\n    get: function () {\n      return this._urlString;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Ensure urls are lower case and end with a / character.\r\n   * @param url\r\n   */\n  UrlString.canonicalizeUri = function (url) {\n    if (url) {\n      var lowerCaseUrl = url.toLowerCase();\n      if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -1);\n      } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -2);\n      }\n      if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\n        lowerCaseUrl += \"/\";\n      }\n      return lowerCaseUrl;\n    }\n    return url;\n  };\n  /**\r\n   * Throws if urlString passed is not a valid authority URI string.\r\n   */\n  UrlString.prototype.validateAsUri = function () {\n    // Attempts to parse url for uri components\n    var components;\n    try {\n      components = this.getUrlComponents();\n    } catch (e) {\n      throw ClientConfigurationError.createUrlParseError(e);\n    }\n    // Throw error if URI or path segments are not parseable.\n    if (!components.HostNameAndPort || !components.PathSegments) {\n      throw ClientConfigurationError.createUrlParseError(\"Given url string: \" + this.urlString);\n    }\n    // Throw error if uri is insecure.\n    if (!components.Protocol || components.Protocol.toLowerCase() !== \"https:\") {\n      throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);\n    }\n  };\n  /**\r\n   * Given a url and a query string return the url with provided query string appended\r\n   * @param url\r\n   * @param queryString\r\n   */\n  UrlString.appendQueryString = function (url, queryString) {\n    if (StringUtils.isEmpty(queryString)) {\n      return url;\n    }\n    return url.indexOf(\"?\") < 0 ? url + \"?\" + queryString : url + \"&\" + queryString;\n  };\n  /**\r\n   * Returns a url with the hash removed\r\n   * @param url\r\n   */\n  UrlString.removeHashFromUrl = function (url) {\n    return UrlString.canonicalizeUri(url.split(\"#\")[0]);\n  };\n  /**\r\n   * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\r\n   * @param href The url\r\n   * @param tenantId The tenant id to replace\r\n   */\n  UrlString.prototype.replaceTenantPath = function (tenantId) {\n    var urlObject = this.getUrlComponents();\n    var pathArray = urlObject.PathSegments;\n    if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {\n      pathArray[0] = tenantId;\n    }\n    return UrlString.constructAuthorityUriFromObject(urlObject);\n  };\n  /**\r\n   * Returns the anchor part(#) of the URL\r\n   */\n  UrlString.prototype.getHash = function () {\n    return UrlString.parseHash(this.urlString);\n  };\n  /**\r\n   * Parses out the components from a url string.\r\n   * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\r\n   */\n  UrlString.prototype.getUrlComponents = function () {\n    // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\n    var regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\n    // If url string does not match regEx, we throw an error\n    var match = this.urlString.match(regEx);\n    if (!match) {\n      throw ClientConfigurationError.createUrlParseError(\"Given url string: \" + this.urlString);\n    }\n    // Url component object\n    var urlComponents = {\n      Protocol: match[1],\n      HostNameAndPort: match[4],\n      AbsolutePath: match[5],\n      QueryString: match[7]\n    };\n    var pathSegments = urlComponents.AbsolutePath.split(\"/\");\n    pathSegments = pathSegments.filter(function (val) {\n      return val && val.length > 0;\n    }); // remove empty elements\n    urlComponents.PathSegments = pathSegments;\n    if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith(\"/\")) {\n      urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);\n    }\n    return urlComponents;\n  };\n  UrlString.getDomainFromUrl = function (url) {\n    var regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\n    var match = url.match(regEx);\n    if (!match) {\n      throw ClientConfigurationError.createUrlParseError(\"Given url string: \" + url);\n    }\n    return match[2];\n  };\n  UrlString.getAbsoluteUrl = function (relativeUrl, baseUrl) {\n    if (relativeUrl[0] === Constants.FORWARD_SLASH) {\n      var url = new UrlString(baseUrl);\n      var baseComponents = url.getUrlComponents();\n      return baseComponents.Protocol + \"//\" + baseComponents.HostNameAndPort + relativeUrl;\n    }\n    return relativeUrl;\n  };\n  /**\r\n   * Parses hash string from given string. Returns empty string if no hash symbol is found.\r\n   * @param hashString\r\n   */\n  UrlString.parseHash = function (hashString) {\n    var hashIndex1 = hashString.indexOf(\"#\");\n    var hashIndex2 = hashString.indexOf(\"#/\");\n    if (hashIndex2 > -1) {\n      return hashString.substring(hashIndex2 + 2);\n    } else if (hashIndex1 > -1) {\n      return hashString.substring(hashIndex1 + 1);\n    }\n    return Constants.EMPTY_STRING;\n  };\n  /**\r\n   * Parses query string from given string. Returns empty string if no query symbol is found.\r\n   * @param queryString\r\n   */\n  UrlString.parseQueryString = function (queryString) {\n    var queryIndex1 = queryString.indexOf(\"?\");\n    var queryIndex2 = queryString.indexOf(\"/?\");\n    if (queryIndex2 > -1) {\n      return queryString.substring(queryIndex2 + 2);\n    } else if (queryIndex1 > -1) {\n      return queryString.substring(queryIndex1 + 1);\n    }\n    return Constants.EMPTY_STRING;\n  };\n  UrlString.constructAuthorityUriFromObject = function (urlObject) {\n    return new UrlString(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + urlObject.PathSegments.join(\"/\"));\n  };\n  /**\r\n   * Returns URL hash as server auth code response object.\r\n   */\n  UrlString.getDeserializedHash = function (hash) {\n    // Check if given hash is empty\n    if (StringUtils.isEmpty(hash)) {\n      return {};\n    }\n    // Strip the # symbol if present\n    var parsedHash = UrlString.parseHash(hash);\n    // If # symbol was not present, above will return empty string, so give original hash value\n    var deserializedHash = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);\n    // Check if deserialization didn't work\n    if (!deserializedHash) {\n      throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));\n    }\n    return deserializedHash;\n  };\n  /**\r\n   * Returns URL query string as server auth code response object.\r\n   */\n  UrlString.getDeserializedQueryString = function (query) {\n    // Check if given query is empty\n    if (StringUtils.isEmpty(query)) {\n      return {};\n    }\n    // Strip the ? symbol if present\n    var parsedQueryString = UrlString.parseQueryString(query);\n    // If ? symbol was not present, above will return empty string, so give original query value\n    var deserializedQueryString = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedQueryString) ? query : parsedQueryString);\n    // Check if deserialization didn't work\n    if (!deserializedQueryString) {\n      throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));\n    }\n    return deserializedQueryString;\n  };\n  /**\r\n   * Check if the hash of the URL string contains known properties\r\n   */\n  UrlString.hashContainsKnownProperties = function (hash) {\n    if (StringUtils.isEmpty(hash) || hash.indexOf(\"=\") < 0) {\n      // Hash doesn't contain key/value pairs\n      return false;\n    }\n    var parameters = UrlString.getDeserializedHash(hash);\n    return !!(parameters.code || parameters.error_description || parameters.error || parameters.state);\n  };\n  return UrlString;\n}();\nexport { UrlString };\n//# sourceMappingURL=UrlString.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}