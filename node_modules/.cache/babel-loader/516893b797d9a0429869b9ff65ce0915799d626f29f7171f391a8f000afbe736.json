{"ast":null,"code":"import { msalInstance } from '../auth/AuthProvider';\nimport { protectedResources } from '../auth/authConfig';\n\n// Base URL for API requests\nconst API_BASE_URL = protectedResources.timeSheetApi.endpoint;\n\n// Token cache to avoid excessive requests\nlet tokenCache = null;\n\n// Get the authentication token\nconst getToken = async () => {\n  try {\n    // Check if we have a valid cached token\n    if (tokenCache && tokenCache.expiresAt > Date.now()) {\n      console.log(\"Using cached token\");\n      return tokenCache.token;\n    }\n    const account = msalInstance.getActiveAccount();\n    if (!account) {\n      console.warn('No active account! Proceeding without authentication token.');\n      return null;\n    }\n    try {\n      const tokenResponse = await msalInstance.acquireTokenSilent({\n        scopes: protectedResources.timeSheetApi.scopes,\n        account: account\n      });\n\n      // Cache the token with expiration (subtract 5 minutes for safety)\n      const expiresInMs = tokenResponse.expiresOn ? tokenResponse.expiresOn.getTime() - Date.now() - 5 * 60 * 1000 : 3600 * 1000; // Default to 1 hour if no expiration\n\n      tokenCache = {\n        token: tokenResponse.accessToken,\n        expiresAt: Date.now() + expiresInMs\n      };\n      return tokenResponse.accessToken;\n    } catch (tokenError) {\n      console.warn('Failed to get token, proceeding with unauthenticated request:', tokenError);\n      return null;\n    }\n  } catch (error) {\n    console.error('Failed to get token:', error);\n    return null;\n  }\n};\n\n// Get authenticated headers\nconst getAuthHeaders = async () => {\n  const token = await getToken();\n  const headers = {\n    'Content-Type': 'application/json'\n  };\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`;\n  }\n  return headers;\n};\n\n// Get timesheets for the current user\nexport async function getTimesheets(userInfo) {\n  try {\n    const headers = await getAuthHeaders();\n    const response = await fetch(`${API_BASE_URL}/timesheets?userId=${userInfo.userId}`, {\n      headers\n    });\n    if (!response.ok) {\n      throw new Error(`Error fetching timesheets: ${response.statusText}`);\n    }\n    const data = await response.json();\n    return data.timesheets || [];\n  } catch (error) {\n    console.error('Failed to fetch timesheets:', error);\n    throw error;\n  }\n}\n\n// Save a timesheet with user information\nexport async function saveTimesheet(timesheet, userInfo) {\n  try {\n    const headers = await getAuthHeaders();\n\n    // Ensure user information is included in the timesheet\n    const timesheetWithUser = {\n      ...timesheet,\n      userId: userInfo.userId,\n      userEmail: userInfo.email,\n      userName: userInfo.name,\n      updatedAt: new Date().toISOString()\n    };\n    const response = await fetch(`${API_BASE_URL}/timesheets`, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(timesheetWithUser)\n    });\n    if (!response.ok) {\n      throw new Error(`Error saving timesheet: ${response.statusText}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Failed to save timesheet:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["msalInstance","protectedResources","API_BASE_URL","timeSheetApi","endpoint","tokenCache","getToken","expiresAt","Date","now","console","log","token","account","getActiveAccount","warn","tokenResponse","acquireTokenSilent","scopes","expiresInMs","expiresOn","getTime","accessToken","tokenError","error","getAuthHeaders","headers","getTimesheets","userInfo","response","fetch","userId","ok","Error","statusText","data","json","timesheets","saveTimesheet","timesheet","timesheetWithUser","userEmail","email","userName","name","updatedAt","toISOString","method","body","JSON","stringify"],"sources":["/Users/theo/Documents/GitHub/weekly-time-allocation/src/services/timesheetService.ts"],"sourcesContent":["import { TimeSheet, UserInfo } from '../models/types';\nimport { msalInstance } from '../auth/AuthProvider';\nimport { protectedResources } from '../auth/authConfig';\n\n// Base URL for API requests\nconst API_BASE_URL = protectedResources.timeSheetApi.endpoint;\n\n// Token cache to avoid excessive requests\nlet tokenCache: {\n  token: string;\n  expiresAt: number;\n} | null = null;\n\n// Get the authentication token\nconst getToken = async (): Promise<string | null> => {\n  try {\n    // Check if we have a valid cached token\n    if (tokenCache && tokenCache.expiresAt > Date.now()) {\n      console.log(\"Using cached token\");\n      return tokenCache.token;\n    }\n\n    const account = msalInstance.getActiveAccount();\n    if (!account) {\n      console.warn('No active account! Proceeding without authentication token.');\n      return null;\n    }\n    \n    try {\n      const tokenResponse = await msalInstance.acquireTokenSilent({\n        scopes: protectedResources.timeSheetApi.scopes,\n        account: account\n      });\n      \n      // Cache the token with expiration (subtract 5 minutes for safety)\n      const expiresInMs = tokenResponse.expiresOn ? \n        (tokenResponse.expiresOn.getTime() - Date.now() - 5 * 60 * 1000) : \n        (3600 * 1000); // Default to 1 hour if no expiration\n\n      tokenCache = {\n        token: tokenResponse.accessToken,\n        expiresAt: Date.now() + expiresInMs\n      };\n      \n      return tokenResponse.accessToken;\n    } catch (tokenError) {\n      console.warn('Failed to get token, proceeding with unauthenticated request:', tokenError);\n      return null;\n    }\n  } catch (error) {\n    console.error('Failed to get token:', error);\n    return null;\n  }\n};\n\n// Get authenticated headers\nconst getAuthHeaders = async (): Promise<HeadersInit> => {\n  const token = await getToken();\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json'\n  };\n  \n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`;\n  }\n  \n  return headers;\n};\n\n// Get timesheets for the current user\nexport async function getTimesheets(userInfo: UserInfo): Promise<TimeSheet[]> {\n  try {\n    const headers = await getAuthHeaders();\n    \n    const response = await fetch(`${API_BASE_URL}/timesheets?userId=${userInfo.userId}`, {\n      headers\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Error fetching timesheets: ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    return data.timesheets || [];\n  } catch (error) {\n    console.error('Failed to fetch timesheets:', error);\n    throw error;\n  }\n}\n\n// Save a timesheet with user information\nexport async function saveTimesheet(timesheet: TimeSheet, userInfo: UserInfo): Promise<{ id: string, message: string }> {\n  try {\n    const headers = await getAuthHeaders();\n    \n    // Ensure user information is included in the timesheet\n    const timesheetWithUser = {\n      ...timesheet,\n      userId: userInfo.userId,\n      userEmail: userInfo.email,\n      userName: userInfo.name,\n      updatedAt: new Date().toISOString()\n    };\n    \n    const response = await fetch(`${API_BASE_URL}/timesheets`, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(timesheetWithUser)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Error saving timesheet: ${response.statusText}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Failed to save timesheet:', error);\n    throw error;\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}