{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { UrlString, AuthError, PerformanceEvents, Constants, ThrottlingUtils, ProtocolUtils } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.js';\nimport { TemporaryCacheKeys, ApiId, InteractionType } from '../utils/BrowserConstants.js';\nimport { RedirectHandler } from '../interaction_handler/RedirectHandler.js';\nimport { BrowserUtils } from '../utils/BrowserUtils.js';\nimport { EventType } from '../event/EventType.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { NativeInteractionClient } from './NativeInteractionClient.js';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar RedirectClient = /** @class */function (_super) {\n  __extends(RedirectClient, _super);\n  function RedirectClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n    var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId) || this;\n    _this.nativeStorage = nativeStorageImpl;\n    return _this;\n  }\n  /**\r\n   * Redirects the page to the /authorize endpoint of the IDP\r\n   * @param request\r\n   */\n  RedirectClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var validRequest, serverTelemetryManager, handleBackButton, authCodeRequest, authClient, interactionHandler, navigateUrl, redirectStartPage, e_1;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);\n            return [4 /*yield*/, this.initializeAuthorizationRequest(request, InteractionType.Redirect)];\n          case 1:\n            validRequest = _a.sent();\n            this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || Constants.EMPTY_STRING, validRequest.account || null);\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect);\n            handleBackButton = function (event) {\n              // Clear temporary cache if the back button is clicked during the redirect flow.\n              if (event.persisted) {\n                _this.logger.verbose(\"Page was restored from back/forward cache. Clearing temporary cache.\");\n                _this.browserStorage.cleanRequestByState(validRequest.state);\n                _this.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect);\n              }\n            };\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 7,, 8]);\n            // Create auth code request and generate PKCE params\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);\n            return [4 /*yield*/, this.initializeAuthorizationCodeRequest(validRequest)];\n          case 3:\n            authCodeRequest = _a.sent();\n            // Initialize the client\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, request.correlationId);\n            return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions)];\n          case 4:\n            authClient = _a.sent();\n            this.logger.verbose(\"Auth code client created\");\n            interactionHandler = new RedirectHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.browserCrypto, this.performanceClient);\n            return [4 /*yield*/, authClient.getAuthCodeUrl(__assign(__assign({}, validRequest), {\n              nativeBroker: NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme)\n            }))];\n          case 5:\n            navigateUrl = _a.sent();\n            redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);\n            this.logger.verbosePii(\"Redirect start page: \" + redirectStartPage);\n            // Clear temporary cache if the back button is clicked during the redirect flow.\n            window.addEventListener(\"pageshow\", handleBackButton);\n            return [4 /*yield*/, interactionHandler.initiateAuthRequest(navigateUrl, {\n              navigationClient: this.navigationClient,\n              redirectTimeout: this.config.system.redirectNavigationTimeout,\n              redirectStartPage: redirectStartPage,\n              onRedirectNavigate: request.onRedirectNavigate\n            })];\n          case 6:\n            // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\n            return [2 /*return*/, _a.sent()];\n          case 7:\n            e_1 = _a.sent();\n            if (e_1 instanceof AuthError) {\n              e_1.setCorrelationId(this.correlationId);\n            }\n            window.removeEventListener(\"pageshow\", handleBackButton);\n            serverTelemetryManager.cacheFailedRequest(e_1);\n            this.browserStorage.cleanRequestByState(validRequest.state);\n            throw e_1;\n          case 8:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Checks if navigateToLoginRequestUrl is set, and:\r\n   * - if true, performs logic to cache and navigate\r\n   * - if false, handles hash string and parses response\r\n   * @param hash\r\n   */\n  RedirectClient.prototype.handleRedirectPromise = function (hash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var serverTelemetryManager, responseHash, state, serverParams, loginRequestUrl, loginRequestUrlNormalized, currentUrlNormalized, handleHashResult, navigationOptions, processHashOnRedirect, homepage, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise);\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 10,, 11]);\n            if (!this.browserStorage.isInteractionInProgress(true)) {\n              this.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\n              return [2 /*return*/, null];\n            }\n            responseHash = this.getRedirectResponseHash(hash || window.location.hash);\n            if (!responseHash) {\n              // Not a recognized server response hash or hash not associated with a redirect request\n              this.logger.info(\"handleRedirectPromise did not detect a response hash as a result of a redirect. Cleaning temporary cache.\");\n              this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n              return [2 /*return*/, null];\n            }\n            state = void 0;\n            try {\n              serverParams = UrlString.getDeserializedHash(responseHash);\n              state = this.validateAndExtractStateFromHash(serverParams, InteractionType.Redirect);\n              this.logger.verbose(\"State extracted from hash\");\n            } catch (e) {\n              this.logger.info(\"handleRedirectPromise was unable to extract state due to: \" + e);\n              this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n              return [2 /*return*/, null];\n            }\n            loginRequestUrl = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || Constants.EMPTY_STRING;\n            loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);\n            currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);\n            if (!(loginRequestUrlNormalized === currentUrlNormalized && this.config.auth.navigateToLoginRequestUrl)) return [3 /*break*/, 3];\n            // We are on the page we need to navigate to - handle hash\n            this.logger.verbose(\"Current page is loginRequestUrl, handling hash\");\n            return [4 /*yield*/, this.handleHash(responseHash, state, serverTelemetryManager)];\n          case 2:\n            handleHashResult = _a.sent();\n            if (loginRequestUrl.indexOf(\"#\") > -1) {\n              // Replace current hash with non-msal hash, if present\n              BrowserUtils.replaceHash(loginRequestUrl);\n            }\n            return [2 /*return*/, handleHashResult];\n          case 3:\n            if (!!this.config.auth.navigateToLoginRequestUrl) return [3 /*break*/, 4];\n            this.logger.verbose(\"NavigateToLoginRequestUrl set to false, handling hash\");\n            return [2 /*return*/, this.handleHash(responseHash, state, serverTelemetryManager)];\n          case 4:\n            if (!(!BrowserUtils.isInIframe() || this.config.system.allowRedirectInIframe)) return [3 /*break*/, 9];\n            /*\r\n             * Returned from authority using redirect - need to perform navigation before processing response\r\n             * Cache the hash to be retrieved after the next redirect\r\n             */\n            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseHash, true);\n            navigationOptions = {\n              apiId: ApiId.handleRedirectPromise,\n              timeout: this.config.system.redirectNavigationTimeout,\n              noHistory: true\n            };\n            processHashOnRedirect = true;\n            if (!(!loginRequestUrl || loginRequestUrl === \"null\")) return [3 /*break*/, 6];\n            homepage = BrowserUtils.getHomepage();\n            // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\n            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);\n            this.logger.warning(\"Unable to get valid login request url from cache, redirecting to home page\");\n            return [4 /*yield*/, this.navigationClient.navigateInternal(homepage, navigationOptions)];\n          case 5:\n            processHashOnRedirect = _a.sent();\n            return [3 /*break*/, 8];\n          case 6:\n            // Navigate to page that initiated the redirect request\n            this.logger.verbose(\"Navigating to loginRequestUrl: \" + loginRequestUrl);\n            return [4 /*yield*/, this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions)];\n          case 7:\n            processHashOnRedirect = _a.sent();\n            _a.label = 8;\n          case 8:\n            // If navigateInternal implementation returns false, handle the hash now\n            if (!processHashOnRedirect) {\n              return [2 /*return*/, this.handleHash(responseHash, state, serverTelemetryManager)];\n            }\n            _a.label = 9;\n          case 9:\n            return [2 /*return*/, null];\n          case 10:\n            e_2 = _a.sent();\n            if (e_2 instanceof AuthError) {\n              e_2.setCorrelationId(this.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e_2);\n            this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n            throw e_2;\n          case 11:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Gets the response hash for a redirect request\r\n   * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\r\n   * @param hash\r\n   */\n  RedirectClient.prototype.getRedirectResponseHash = function (hash) {\n    this.logger.verbose(\"getRedirectResponseHash called\");\n    // Get current location hash from window or cache.\n    var isResponseHash = UrlString.hashContainsKnownProperties(hash);\n    if (isResponseHash) {\n      BrowserUtils.clearHash(window);\n      this.logger.verbose(\"Hash contains known properties, returning response hash\");\n      return hash;\n    }\n    var cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);\n    this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.logger.verbose(\"Hash does not contain known properties, returning cached hash\");\n    return cachedHash;\n  };\n  /**\r\n   * Checks if hash exists and handles in window.\r\n   * @param hash\r\n   * @param state\r\n   */\n  RedirectClient.prototype.handleHash = function (hash, state, serverTelemetryManager) {\n    return __awaiter(this, void 0, void 0, function () {\n      var cachedRequest, serverParams, nativeInteractionClient, userRequestState, currentAuthority, authClient, interactionHandler;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            cachedRequest = this.browserStorage.getCachedRequest(state, this.browserCrypto);\n            this.logger.verbose(\"handleHash called, retrieved cached request\");\n            serverParams = UrlString.getDeserializedHash(hash);\n            if (serverParams.accountId) {\n              this.logger.verbose(\"Account id found in hash, calling WAM for token\");\n              if (!this.nativeMessageHandler) {\n                throw BrowserAuthError.createNativeConnectionNotEstablishedError();\n              }\n              nativeInteractionClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, serverParams.accountId, this.nativeStorage, cachedRequest.correlationId);\n              userRequestState = ProtocolUtils.parseRequestState(this.browserCrypto, state).userRequestState;\n              return [2 /*return*/, nativeInteractionClient.acquireToken(__assign(__assign({}, cachedRequest), {\n                state: userRequestState,\n                prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently\n              })).finally(function () {\n                _this.browserStorage.cleanRequestByState(state);\n              })];\n            }\n            currentAuthority = this.browserStorage.getCachedAuthority(state);\n            if (!currentAuthority) {\n              throw BrowserAuthError.createNoCachedAuthorityError();\n            }\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, cachedRequest.correlationId);\n            return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, currentAuthority)];\n          case 1:\n            authClient = _a.sent();\n            this.logger.verbose(\"Auth code client created\");\n            ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, cachedRequest);\n            interactionHandler = new RedirectHandler(authClient, this.browserStorage, cachedRequest, this.logger, this.browserCrypto, this.performanceClient);\n            return [4 /*yield*/, interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient)];\n          case 2:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param logoutRequest\r\n   */\n  RedirectClient.prototype.logout = function (logoutRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var validLogoutRequest, serverTelemetryManager, navigationOptions, authClient, logoutUri, navigate, e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"logoutRedirect called\");\n            validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logout);\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 10,, 11]);\n            this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);\n            // Clear cache on logout\n            return [4 /*yield*/, this.clearCacheOnLogout(validLogoutRequest.account)];\n          case 2:\n            // Clear cache on logout\n            _a.sent();\n            navigationOptions = {\n              apiId: ApiId.logout,\n              timeout: this.config.system.redirectNavigationTimeout,\n              noHistory: false\n            };\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, validLogoutRequest.correlationId);\n            return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, logoutRequest && logoutRequest.authority)];\n          case 3:\n            authClient = _a.sent();\n            this.logger.verbose(\"Auth code client created\");\n            logoutUri = authClient.getLogoutUri(validLogoutRequest);\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n            if (!(logoutRequest && typeof logoutRequest.onRedirectNavigate === \"function\")) return [3 /*break*/, 7];\n            navigate = logoutRequest.onRedirectNavigate(logoutUri);\n            if (!(navigate !== false)) return [3 /*break*/, 5];\n            this.logger.verbose(\"Logout onRedirectNavigate did not return false, navigating\");\n            // Ensure interaction is in progress\n            if (!this.browserStorage.getInteractionInProgress()) {\n              this.browserStorage.setInteractionInProgress(true);\n            }\n            return [4 /*yield*/, this.navigationClient.navigateExternal(logoutUri, navigationOptions)];\n          case 4:\n            _a.sent();\n            return [2 /*return*/];\n          case 5:\n            // Ensure interaction is not in progress\n            this.browserStorage.setInteractionInProgress(false);\n            this.logger.verbose(\"Logout onRedirectNavigate returned false, stopping navigation\");\n            _a.label = 6;\n          case 6:\n            return [3 /*break*/, 9];\n          case 7:\n            // Ensure interaction is in progress\n            if (!this.browserStorage.getInteractionInProgress()) {\n              this.browserStorage.setInteractionInProgress(true);\n            }\n            return [4 /*yield*/, this.navigationClient.navigateExternal(logoutUri, navigationOptions)];\n          case 8:\n            _a.sent();\n            return [2 /*return*/];\n          case 9:\n            return [3 /*break*/, 11];\n          case 10:\n            e_3 = _a.sent();\n            if (e_3 instanceof AuthError) {\n              e_3.setCorrelationId(this.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e_3);\n            this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e_3);\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n            throw e_3;\n          case 11:\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Use to get the redirectStartPage either from request or use current window\r\n   * @param requestStartPage\r\n   */\n  RedirectClient.prototype.getRedirectStartPage = function (requestStartPage) {\n    var redirectStartPage = requestStartPage || window.location.href;\n    return UrlString.getAbsoluteUrl(redirectStartPage, BrowserUtils.getCurrentUri());\n  };\n  return RedirectClient;\n}(StandardInteractionClient);\nexport { RedirectClient };\n//# sourceMappingURL=RedirectClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}