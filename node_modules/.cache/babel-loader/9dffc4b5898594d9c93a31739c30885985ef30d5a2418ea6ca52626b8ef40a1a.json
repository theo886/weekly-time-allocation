{"ast":null,"code":"/*! @azure/msal-common v13.3.3 2024-06-06 */\n'use strict';\n\nimport { __extends } from '../../_virtual/_tslib.js';\nimport { CredentialEntity } from './CredentialEntity.js';\nimport { CredentialType, AuthenticationScheme } from '../../utils/Constants.js';\nimport { TimeUtils } from '../../utils/TimeUtils.js';\nimport { StringUtils } from '../../utils/StringUtils.js';\nimport { AuthToken } from '../../account/AuthToken.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * ACCESS_TOKEN Credential Type\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      cachedAt: Absolute device time when entry was created in the cache.\r\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\r\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\r\n *      keyId: used for POP and SSH tokenTypes\r\n *      tokenType: Type of the token issued. Usually \"Bearer\"\r\n * }\r\n */\nvar AccessTokenEntity = /** @class */function (_super) {\n  __extends(AccessTokenEntity, _super);\n  function AccessTokenEntity() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Create AccessTokenEntity\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param accessToken\r\n   * @param clientId\r\n   * @param tenantId\r\n   * @param scopes\r\n   * @param expiresOn\r\n   * @param extExpiresOn\r\n   */\n  AccessTokenEntity.createAccessTokenEntity = function (homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {\n    var _a, _b;\n    var atEntity = new AccessTokenEntity();\n    atEntity.homeAccountId = homeAccountId;\n    atEntity.credentialType = CredentialType.ACCESS_TOKEN;\n    atEntity.secret = accessToken;\n    var currentTime = TimeUtils.nowSeconds();\n    atEntity.cachedAt = currentTime.toString();\n    /*\r\n     * Token expiry time.\r\n     * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\r\n     */\n    atEntity.expiresOn = expiresOn.toString();\n    atEntity.extendedExpiresOn = extExpiresOn.toString();\n    if (refreshOn) {\n      atEntity.refreshOn = refreshOn.toString();\n    }\n    atEntity.environment = environment;\n    atEntity.clientId = clientId;\n    atEntity.realm = tenantId;\n    atEntity.target = scopes;\n    atEntity.userAssertionHash = userAssertionHash;\n    atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;\n    if (requestedClaims) {\n      atEntity.requestedClaims = requestedClaims;\n      atEntity.requestedClaimsHash = requestedClaimsHash;\n    }\n    /*\r\n     * Create Access Token With Auth Scheme instead of regular access token\r\n     * Cast to lower to handle \"bearer\" from ADFS\r\n     */\n    if (((_a = atEntity.tokenType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {\n      atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n      switch (atEntity.tokenType) {\n        case AuthenticationScheme.POP:\n          // Make sure keyId is present and add it to credential\n          var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);\n          if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {\n            throw ClientAuthError.createTokenClaimsRequiredError();\n          }\n          atEntity.keyId = tokenClaims.cnf.kid;\n          break;\n        case AuthenticationScheme.SSH:\n          atEntity.keyId = keyId;\n      }\n    }\n    return atEntity;\n  };\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n  AccessTokenEntity.isAccessTokenEntity = function (entity) {\n    if (!entity) {\n      return false;\n    }\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"credentialType\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"clientId\") && entity.hasOwnProperty(\"secret\") && entity.hasOwnProperty(\"target\") && (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n  };\n  return AccessTokenEntity;\n}(CredentialEntity);\nexport { AccessTokenEntity };\n//# sourceMappingURL=AccessTokenEntity.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}