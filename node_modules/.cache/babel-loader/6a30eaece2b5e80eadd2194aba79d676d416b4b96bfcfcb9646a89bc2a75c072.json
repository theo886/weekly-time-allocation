{"ast":null,"code":"/*! @azure/msal-common v13.3.3 2024-06-06 */\n'use strict';\n\nimport { __awaiter, __assign, __extends, __generator } from '../_virtual/_tslib.js';\nimport { Separators, CredentialType, AuthenticationScheme, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from './entities/AccountEntity.js';\nimport { AuthError } from '../error/AuthError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { name, version } from '../packageMetadata.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\nvar CacheManager = /** @class */function () {\n  function CacheManager(clientId, cryptoImpl, logger) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n    this.commonLogger = logger.clone(name, version);\n  }\n  /**\r\n   * Returns all accounts in cache\r\n   */\n  CacheManager.prototype.getAllAccounts = function () {\n    var _this = this;\n    var allAccountKeys = this.getAccountKeys();\n    if (allAccountKeys.length < 1) {\n      return [];\n    }\n    var accountEntities = allAccountKeys.reduce(function (accounts, key) {\n      var entity = _this.getAccount(key);\n      if (!entity) {\n        return accounts;\n      }\n      accounts.push(entity);\n      return accounts;\n    }, []);\n    if (accountEntities.length < 1) {\n      return [];\n    } else {\n      var allAccounts = accountEntities.map(function (accountEntity) {\n        return _this.getAccountInfoFromEntity(accountEntity);\n      });\n      return allAccounts;\n    }\n  };\n  /**\r\n   * Gets accountInfo object based on provided filters\r\n   */\n  CacheManager.prototype.getAccountInfoFilteredBy = function (accountFilter) {\n    var allAccounts = this.getAccountsFilteredBy(accountFilter);\n    if (allAccounts.length > 0) {\n      return this.getAccountInfoFromEntity(allAccounts[0]);\n    } else {\n      return null;\n    }\n  };\n  CacheManager.prototype.getAccountInfoFromEntity = function (accountEntity) {\n    var accountInfo = accountEntity.getAccountInfo();\n    var idToken = this.getIdToken(accountInfo);\n    if (idToken) {\n      accountInfo.idToken = idToken.secret;\n      accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\n    }\n    return accountInfo;\n  };\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord\r\n   */\n  CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!cacheRecord) {\n              throw ClientAuthError.createNullOrUndefinedCacheRecord();\n            }\n            if (!!cacheRecord.account) {\n              this.setAccount(cacheRecord.account);\n            }\n            if (!!cacheRecord.idToken) {\n              this.setIdTokenCredential(cacheRecord.idToken);\n            }\n            if (!!!cacheRecord.accessToken) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.saveAccessToken(cacheRecord.accessToken)];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            if (!!cacheRecord.refreshToken) {\n              this.setRefreshTokenCredential(cacheRecord.refreshToken);\n            }\n            if (!!cacheRecord.appMetadata) {\n              this.setAppMetadata(cacheRecord.appMetadata);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n  CacheManager.prototype.saveAccessToken = function (credential) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accessTokenFilter, tokenKeys, currentScopes, removedAccessTokens;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            accessTokenFilter = {\n              clientId: credential.clientId,\n              credentialType: credential.credentialType,\n              environment: credential.environment,\n              homeAccountId: credential.homeAccountId,\n              realm: credential.realm,\n              tokenType: credential.tokenType,\n              requestedClaimsHash: credential.requestedClaimsHash\n            };\n            tokenKeys = this.getTokenKeys();\n            currentScopes = ScopeSet.fromString(credential.target);\n            removedAccessTokens = [];\n            tokenKeys.accessToken.forEach(function (key) {\n              if (!_this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n                return;\n              }\n              var tokenEntity = _this.getAccessTokenCredential(key);\n              if (tokenEntity && _this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n                var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                  removedAccessTokens.push(_this.removeAccessToken(key));\n                }\n              }\n            });\n            return [4 /*yield*/, Promise.all(removedAccessTokens)];\n          case 1:\n            _a.sent();\n            this.setAccessTokenCredential(credential);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n  CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\n    var _this = this;\n    var allAccountKeys = this.getAccountKeys();\n    var matchingAccounts = [];\n    allAccountKeys.forEach(function (cacheKey) {\n      if (!_this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {\n        // Don't parse value if the key doesn't match the account filters\n        return;\n      }\n      var entity = _this.getAccount(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!accountFilter.homeAccountId && !_this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.localAccountId && !_this.matchLocalAccountId(entity, accountFilter.localAccountId)) {\n        return;\n      }\n      if (!!accountFilter.username && !_this.matchUsername(entity, accountFilter.username)) {\n        return;\n      }\n      if (!!accountFilter.environment && !_this.matchEnvironment(entity, accountFilter.environment)) {\n        return;\n      }\n      if (!!accountFilter.realm && !_this.matchRealm(entity, accountFilter.realm)) {\n        return;\n      }\n      if (!!accountFilter.nativeAccountId && !_this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n        return;\n      }\n      matchingAccounts.push(entity);\n    });\n    return matchingAccounts;\n  };\n  /**\r\n   * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\r\n   * @param key\r\n   * @param homeAccountId\r\n   * @param tenantId\r\n   * @returns\r\n   */\n  CacheManager.prototype.isAccountKey = function (key, homeAccountId, tenantId) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n      // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\n      return false;\n    }\n    if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n      return false;\n    }\n    // Do not check environment as aliasing can cause false negatives\n    return true;\n  };\n  /**\r\n   * Returns true if the given key matches our credential key schema.\r\n   * @param key\r\n   */\n  CacheManager.prototype.isCredentialKey = function (key) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n      // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    var lowerCaseKey = key.toLowerCase();\n    // Credential keys must indicate what credential type they represent\n    if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {\n      return false;\n    }\n    if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\n      // Refresh tokens must contain the client id or family id\n      var clientIdValidation = \"\" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + this.clientId + Separators.CACHE_KEY_SEPARATOR;\n      var familyIdValidation = \"\" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + THE_FAMILY_ID + Separators.CACHE_KEY_SEPARATOR;\n      if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\n        return false;\n      }\n    } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n      // Tokens must contain the clientId\n      return false;\n    }\n    return true;\n  };\n  /**\r\n   * Returns whether or not the given credential entity matches the filter\r\n   * @param entity\r\n   * @param filter\r\n   * @returns\r\n   */\n  CacheManager.prototype.credentialMatchesFilter = function (entity, filter) {\n    if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n      return false;\n    }\n    if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n      return false;\n    }\n    /*\r\n     * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n     * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n     */\n    if (typeof filter.homeAccountId === \"string\" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n      return false;\n    }\n    if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n      return false;\n    }\n    if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n      return false;\n    }\n    if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\n      return false;\n    }\n    if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n      return false;\n    }\n    /*\r\n     * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n     * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n     */\n    if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n      return false;\n    }\n    // If request OR cached entity has requested Claims Hash, check if they match\n    if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n      // Don't match if either is undefined or they are different\n      if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n        return false;\n      }\n    }\n    // Access Token with Auth Scheme specific matching\n    if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n      if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\n        return false;\n      }\n      // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n      if (filter.tokenType === AuthenticationScheme.SSH) {\n        if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n  CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  };\n  /**\r\n   * Support function to help match appMetadata\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    var matchingAppMetadata = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-appMetadata type cache entities\n      if (!_this.isAppMetadata(cacheKey)) {\n        return;\n      }\n      // Attempt retrieval\n      var entity = _this.getAppMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  };\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n  CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\n    var _this = this;\n    var allCacheKeys = this.getAuthorityMetadataKeys();\n    var matchedEntity = null;\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\n        return;\n      }\n      // Attempt retrieval\n      var entity = _this.getAuthorityMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  };\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n  CacheManager.prototype.removeAllAccounts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var allAccountKeys, removedAccounts;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allAccountKeys = this.getAccountKeys();\n            removedAccounts = [];\n            allAccountKeys.forEach(function (cacheKey) {\n              removedAccounts.push(_this.removeAccount(cacheKey));\n            });\n            return [4 /*yield*/, Promise.all(removedAccounts)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes the account and related tokens for a given account key\r\n   * @param account\r\n   */\n  CacheManager.prototype.removeAccount = function (accountKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            account = this.getAccount(accountKey);\n            if (!account) {\n              throw ClientAuthError.createNoAccountFoundError();\n            }\n            return [4 /*yield*/, this.removeAccountContext(account)];\n          case 1:\n            _a.sent();\n            this.removeItem(accountKey);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n  CacheManager.prototype.removeAccountContext = function (account) {\n    return __awaiter(this, void 0, void 0, function () {\n      var allTokenKeys, accountId, removedCredentials;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allTokenKeys = this.getTokenKeys();\n            accountId = account.generateAccountId();\n            removedCredentials = [];\n            allTokenKeys.idToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                _this.removeIdToken(key);\n              }\n            });\n            allTokenKeys.accessToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                removedCredentials.push(_this.removeAccessToken(key));\n              }\n            });\n            allTokenKeys.refreshToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                _this.removeRefreshToken(key);\n              }\n            });\n            return [4 /*yield*/, Promise.all(removedCredentials)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given credential is removed\r\n   * @param credential\r\n   */\n  CacheManager.prototype.removeAccessToken = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var credential, accessTokenWithAuthSchemeEntity, kid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            credential = this.getAccessTokenCredential(key);\n            if (!credential) {\n              return [2 /*return*/];\n            }\n            if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3 /*break*/, 4];\n            if (!(credential.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 4];\n            accessTokenWithAuthSchemeEntity = credential;\n            kid = accessTokenWithAuthSchemeEntity.keyId;\n            if (!kid) return [3 /*break*/, 4];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.cryptoImpl.removeTokenBindingKey(kid)];\n          case 2:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            _a.sent();\n            throw ClientAuthError.createBindingKeyNotRemovedError();\n          case 4:\n            return [2 /*return*/, this.removeItem(key)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n  CacheManager.prototype.removeAppMetadata = function () {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      if (_this.isAppMetadata(cacheKey)) {\n        _this.removeItem(cacheKey);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * Retrieve the cached credentials into a cacherecord\r\n   * @param account\r\n   * @param clientId\r\n   * @param scopes\r\n   * @param environment\r\n   * @param authScheme\r\n   */\n  CacheManager.prototype.readCacheRecord = function (account, request, environment) {\n    var tokenKeys = this.getTokenKeys();\n    var cachedAccount = this.readAccountFromCache(account);\n    var cachedIdToken = this.getIdToken(account, tokenKeys);\n    var cachedAccessToken = this.getAccessToken(account, request, tokenKeys);\n    var cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);\n    var cachedAppMetadata = this.readAppMetadataFromCache(environment);\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n    }\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param account\r\n   */\n  CacheManager.prototype.readAccountFromCache = function (account) {\n    var accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  };\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param inputRealm\r\n   */\n  CacheManager.prototype.getIdToken = function (account, tokenKeys) {\n    var _this = this;\n    this.commonLogger.trace(\"CacheManager - getIdToken called\");\n    var idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.clientId,\n      realm: account.tenantId\n    };\n    var idTokens = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\n    var numIdTokens = idTokens.length;\n    if (numIdTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n      return null;\n    } else if (numIdTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - Multiple id tokens found, clearing them\");\n      idTokens.forEach(function (idToken) {\n        _this.removeIdToken(idToken.generateCredentialKey());\n      });\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\n    return idTokens[0];\n  };\n  /**\r\n   * Gets all idTokens matching the given filter\r\n   * @param filter\r\n   * @returns\r\n   */\n  CacheManager.prototype.getIdTokensByFilter = function (filter, tokenKeys) {\n    var _this = this;\n    var idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\n    var idTokens = [];\n    idTokenKeys.forEach(function (key) {\n      if (!_this.idTokenKeyMatchesFilter(key, __assign({\n        clientId: _this.clientId\n      }, filter))) {\n        return;\n      }\n      var idToken = _this.getIdTokenCredential(key);\n      if (idToken && _this.credentialMatchesFilter(idToken, filter)) {\n        idTokens.push(idToken);\n      }\n    });\n    return idTokens;\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @returns\r\n   */\n  CacheManager.prototype.idTokenKeyMatchesFilter = function (inputKey, filter) {\n    var key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  };\n  /**\r\n   * Removes idToken from the cache\r\n   * @param key\r\n   */\n  CacheManager.prototype.removeIdToken = function (key) {\n    this.removeItem(key);\n  };\n  /**\r\n   * Removes refresh token from the cache\r\n   * @param key\r\n   */\n  CacheManager.prototype.removeRefreshToken = function (key) {\n    this.removeItem(key);\n  };\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param scopes\r\n   * @param authScheme\r\n   */\n  CacheManager.prototype.getAccessToken = function (account, request, tokenKeys) {\n    var _this = this;\n    this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n    var scopes = ScopeSet.createSearchScopes(request.scopes);\n    var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n    var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: this.clientId,\n      realm: account.tenantId,\n      target: scopes,\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    var accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\n    var accessTokens = [];\n    accessTokenKeys.forEach(function (key) {\n      // Validate key\n      if (_this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n        var accessToken = _this.getAccessTokenCredential(key);\n        // Validate value\n        if (accessToken && _this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n          accessTokens.push(accessToken);\n        }\n      }\n    });\n    var numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\n      return null;\n    } else if (numAccessTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - Multiple access tokens found, clearing them\");\n      accessTokens.forEach(function (accessToken) {\n        _this.removeAccessToken(accessToken.generateCredentialKey());\n      });\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\n    return accessTokens[0];\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @param keyMustContainAllScopes\r\n   * @returns\r\n   */\n  CacheManager.prototype.accessTokenKeyMatchesFilter = function (inputKey, filter, keyMustContainAllScopes) {\n    var key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.target) {\n      var scopes = filter.target.asArray();\n      for (var i = 0; i < scopes.length; i++) {\n        if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache lookup a missing scope would be a cache miss\n          return false;\n        } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache write, any token with a subset of requested scopes should be replaced\n          return true;\n        }\n      }\n    }\n    return true;\n  };\n  /**\r\n   * Gets all access tokens matching the filter\r\n   * @param filter\r\n   * @returns\r\n   */\n  CacheManager.prototype.getAccessTokensByFilter = function (filter) {\n    var _this = this;\n    var tokenKeys = this.getTokenKeys();\n    var accessTokens = [];\n    tokenKeys.accessToken.forEach(function (key) {\n      if (!_this.accessTokenKeyMatchesFilter(key, filter, true)) {\n        return;\n      }\n      var accessToken = _this.getAccessTokenCredential(key);\n      if (accessToken && _this.credentialMatchesFilter(accessToken, filter)) {\n        accessTokens.push(accessToken);\n      }\n    });\n    return accessTokens;\n  };\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param familyRT\r\n   */\n  CacheManager.prototype.getRefreshToken = function (account, familyRT, tokenKeys) {\n    var _this = this;\n    this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n    var id = familyRT ? THE_FAMILY_ID : undefined;\n    var refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: this.clientId,\n      familyId: id\n    };\n    var refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\n    var refreshTokens = [];\n    refreshTokenKeys.forEach(function (key) {\n      // Validate key\n      if (_this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n        var refreshToken = _this.getRefreshTokenCredential(key);\n        // Validate value\n        if (refreshToken && _this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n          refreshTokens.push(refreshToken);\n        }\n      }\n    });\n    var numRefreshTokens = refreshTokens.length;\n    if (numRefreshTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n      return null;\n    }\n    // address the else case after remove functions address environment aliases\n    this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n    return refreshTokens[0];\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   */\n  CacheManager.prototype.refreshTokenKeyMatchesFilter = function (inputKey, filter) {\n    var key = inputKey.toLowerCase();\n    if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\n      return false;\n    }\n    // If familyId is used, clientId is not in the key\n    if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  };\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n  CacheManager.prototype.readAppMetadataFromCache = function (environment) {\n    var appMetadataFilter = {\n      environment: environment,\n      clientId: this.clientId\n    };\n    var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    var appMetadataEntries = Object.keys(appMetadata).map(function (key) {\n      return appMetadata[key];\n    });\n    var numAppMetadata = appMetadataEntries.length;\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n    }\n    return appMetadataEntries[0];\n  };\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.isAppMetadataFOCI = function (environment) {\n    var appMetadata = this.readAppMetadataFromCache(environment);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n  CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param entity\r\n   * @param localAccountId\r\n   * @returns\r\n   */\n  CacheManager.prototype.matchLocalAccountId = function (entity, localAccountId) {\n    return !!(typeof entity.localAccountId === \"string\" && localAccountId === entity.localAccountId);\n  };\n  /**\r\n   * helper to match usernames\r\n   * @param entity\r\n   * @param username\r\n   * @returns\r\n   */\n  CacheManager.prototype.matchUsername = function (entity, username) {\n    return !!(typeof entity.username === \"string\" && username.toLowerCase() === entity.username.toLowerCase());\n  };\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n  CacheManager.prototype.matchUserAssertionHash = function (entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  };\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n  CacheManager.prototype.matchEnvironment = function (entity, environment) {\n    var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n    return false;\n  };\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n  CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  };\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.matchClientId = function (entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  };\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n  CacheManager.prototype.matchFamilyId = function (entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  };\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n  CacheManager.prototype.matchRealm = function (entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  };\n  /**\r\n   * helper to match nativeAccountId\r\n   * @param entity\r\n   * @param nativeAccountId\r\n   * @returns boolean indicating the match result\r\n   */\n  CacheManager.prototype.matchNativeAccountId = function (entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  };\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n  CacheManager.prototype.matchTarget = function (entity, target) {\n    var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n    var entityScopeSet = ScopeSet.fromString(entity.target);\n    return entityScopeSet.containsScopeSet(target);\n  };\n  /**\r\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  CacheManager.prototype.matchTokenType = function (entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  };\n  /**\r\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  CacheManager.prototype.matchKeyId = function (entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  };\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n  CacheManager.prototype.isAppMetadata = function (key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  };\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n  CacheManager.prototype.isAuthorityMetadata = function (key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  };\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n  CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\n    return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\n  };\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n  CacheManager.toObject = function (obj, json) {\n    for (var propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n    return obj;\n  };\n  return CacheManager;\n}();\nvar DefaultStorageClass = /** @class */function (_super) {\n  __extends(DefaultStorageClass, _super);\n  function DefaultStorageClass() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DefaultStorageClass.prototype.setAccount = function () {\n    var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAccount = function () {\n    var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAppMetadata = function () {\n    var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAppMetadata = function () {\n    var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setServerTelemetry = function () {\n    var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getServerTelemetry = function () {\n    var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setThrottlingCache = function () {\n    var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getThrottlingCache = function () {\n    var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.removeItem = function () {\n    var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.containsKey = function () {\n    var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getKeys = function () {\n    var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAccountKeys = function () {\n    var notImplErr = \"Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getTokenKeys = function () {\n    var notImplErr = \"Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var notImplErr;\n      return __generator(this, function (_a) {\n        notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n      });\n    });\n  };\n  DefaultStorageClass.prototype.updateCredentialCacheKey = function () {\n    var notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  return DefaultStorageClass;\n}(CacheManager);\nexport { CacheManager, DefaultStorageClass };\n//# sourceMappingURL=CacheManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}