{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign, __rest } from '../_virtual/_tslib.js';\nimport { ScopeSet, AuthToken, Constants, AccountEntity, AuthorityType, IdTokenEntity, AccessTokenEntity, CacheRecord, AuthenticationScheme, PerformanceEvents, TimeUtils, ClientAuthError, PopTokenGenerator, UrlString, OIDC_DEFAULT_SCOPES, PromptValue } from '@azure/msal-common';\nimport { BaseInteractionClient } from './BaseInteractionClient.js';\nimport { TemporaryCacheKeys, NativeExtensionMethod, NativeConstants, ApiId } from '../utils/BrowserConstants.js';\nimport { NativeAuthError } from '../error/NativeAuthError.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { SilentCacheClient } from './SilentCacheClient.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar NativeInteractionClient = /** @class */function (_super) {\n  __extends(NativeInteractionClient, _super);\n  function NativeInteractionClient(config, browserStorage, browserCrypto, logger, eventHandler, navigationClient, apiId, performanceClient, provider, accountId, nativeStorageImpl, correlationId) {\n    var _this = _super.call(this, config, browserStorage, browserCrypto, logger, eventHandler, navigationClient, performanceClient, provider, correlationId) || this;\n    _this.apiId = apiId;\n    _this.accountId = accountId;\n    _this.nativeMessageHandler = provider;\n    _this.nativeStorageManager = nativeStorageImpl;\n    _this.silentCacheClient = new SilentCacheClient(config, _this.nativeStorageManager, browserCrypto, logger, eventHandler, navigationClient, performanceClient, provider, correlationId);\n    return _this;\n  }\n  /**\r\n   * Acquire token from native platform via browser extension\r\n   * @param request\r\n   */\n  NativeInteractionClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var nativeATMeasurement, reqTimestamp, nativeRequest, result, messageBody, response, validatedResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - acquireToken called.\");\n            nativeATMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.NativeInteractionClientAcquireToken, request.correlationId);\n            reqTimestamp = TimeUtils.nowSeconds();\n            return [4 /*yield*/, this.initializeNativeRequest(request)];\n          case 1:\n            nativeRequest = _a.sent();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.acquireTokensFromCache(this.accountId, nativeRequest)];\n          case 3:\n            result = _a.sent();\n            nativeATMeasurement.endMeasurement({\n              success: true,\n              isNativeBroker: false,\n              fromCache: true\n            });\n            return [2 /*return*/, result];\n          case 4:\n            _a.sent();\n            // continue with a native call for any and all errors\n            this.logger.info(\"MSAL internal Cache does not contain tokens, proceed to make a native call\");\n            return [3 /*break*/, 5];\n          case 5:\n            messageBody = {\n              method: NativeExtensionMethod.GetToken,\n              request: nativeRequest\n            };\n            return [4 /*yield*/, this.nativeMessageHandler.sendMessage(messageBody)];\n          case 6:\n            response = _a.sent();\n            validatedResponse = this.validateNativeResponse(response);\n            return [2 /*return*/, this.handleNativeResponse(validatedResponse, nativeRequest, reqTimestamp).then(function (result) {\n              nativeATMeasurement.endMeasurement({\n                success: true,\n                isNativeBroker: true,\n                requestId: result.requestId\n              });\n              return result;\n            }).catch(function (error) {\n              nativeATMeasurement.endMeasurement({\n                success: false,\n                errorCode: error.errorCode,\n                subErrorCode: error.subError,\n                isNativeBroker: true\n              });\n              throw error;\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates silent flow request\r\n   * @param request\r\n   * @param cachedAccount\r\n   * @returns CommonSilentFlowRequest\r\n   */\n  NativeInteractionClient.prototype.createSilentCacheRequest = function (request, cachedAccount) {\n    return {\n      authority: request.authority,\n      correlationId: this.correlationId,\n      scopes: ScopeSet.fromString(request.scope).asArray(),\n      account: cachedAccount,\n      forceRefresh: false\n    };\n  };\n  /**\r\n   * Fetches the tokens from the cache if un-expired\r\n   * @param nativeAccountId\r\n   * @param request\r\n   * @returns authenticationResult\r\n   */\n  NativeInteractionClient.prototype.acquireTokensFromCache = function (nativeAccountId, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var account, silentRequest, result, fullAccount, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!nativeAccountId) {\n              this.logger.warning(\"NativeInteractionClient:acquireTokensFromCache - No nativeAccountId provided\");\n              throw ClientAuthError.createNoAccountFoundError();\n            }\n            account = this.browserStorage.getAccountInfoFilteredBy({\n              nativeAccountId: nativeAccountId\n            });\n            if (!account) {\n              throw ClientAuthError.createNoAccountFoundError();\n            }\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            silentRequest = this.createSilentCacheRequest(request, account);\n            return [4 /*yield*/, this.silentCacheClient.acquireToken(silentRequest)];\n          case 2:\n            result = _a.sent();\n            fullAccount = __assign(__assign({}, account), {\n              idTokenClaims: result.idTokenClaims\n            });\n            return [2 /*return*/, __assign(__assign({}, result), {\n              account: fullAccount\n            })];\n          case 3:\n            e_2 = _a.sent();\n            throw e_2;\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Acquires a token from native platform then redirects to the redirectUri instead of returning the response\r\n   * @param request\r\n   */\n  NativeInteractionClient.prototype.acquireTokenRedirect = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var nativeRequest, messageBody, response, e_3, navigationOptions, redirectUri;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - acquireTokenRedirect called.\");\n            return [4 /*yield*/, this.initializeNativeRequest(request)];\n          case 1:\n            nativeRequest = _a.sent();\n            messageBody = {\n              method: NativeExtensionMethod.GetToken,\n              request: nativeRequest\n            };\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.nativeMessageHandler.sendMessage(messageBody)];\n          case 3:\n            response = _a.sent();\n            this.validateNativeResponse(response);\n            return [3 /*break*/, 5];\n          case 4:\n            e_3 = _a.sent();\n            // Only throw fatal errors here to allow application to fallback to regular redirect. Otherwise proceed and the error will be thrown in handleRedirectPromise\n            if (e_3 instanceof NativeAuthError && e_3.isFatal()) {\n              throw e_3;\n            }\n            return [3 /*break*/, 5];\n          case 5:\n            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, JSON.stringify(nativeRequest), true);\n            navigationOptions = {\n              apiId: ApiId.acquireTokenRedirect,\n              timeout: this.config.system.redirectNavigationTimeout,\n              noHistory: false\n            };\n            redirectUri = this.config.auth.navigateToLoginRequestUrl ? window.location.href : this.getRedirectUri(request.redirectUri);\n            return [4 /*yield*/, this.navigationClient.navigateExternal(redirectUri, navigationOptions)];\n          case 6:\n            _a.sent(); // Need to treat this as external to ensure handleRedirectPromise is run again\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * If the previous page called native platform for a token using redirect APIs, send the same request again and return the response\r\n   */\n  NativeInteractionClient.prototype.handleRedirectPromise = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var cachedRequest, prompt, request, messageBody, reqTimestamp, response, result, e_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - handleRedirectPromise called.\");\n            if (!this.browserStorage.isInteractionInProgress(true)) {\n              this.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\n              return [2 /*return*/, null];\n            }\n            cachedRequest = this.browserStorage.getCachedNativeRequest();\n            if (!cachedRequest) {\n              this.logger.verbose(\"NativeInteractionClient - handleRedirectPromise called but there is no cached request, returning null.\");\n              return [2 /*return*/, null];\n            }\n            prompt = cachedRequest.prompt, request = __rest(cachedRequest, [\"prompt\"]);\n            if (prompt) {\n              this.logger.verbose(\"NativeInteractionClient - handleRedirectPromise called and prompt was included in the original request, removing prompt from cached request to prevent second interaction with native broker window.\");\n            }\n            this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n            messageBody = {\n              method: NativeExtensionMethod.GetToken,\n              request: request\n            };\n            reqTimestamp = TimeUtils.nowSeconds();\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            this.logger.verbose(\"NativeInteractionClient - handleRedirectPromise sending message to native broker.\");\n            return [4 /*yield*/, this.nativeMessageHandler.sendMessage(messageBody)];\n          case 2:\n            response = _a.sent();\n            this.validateNativeResponse(response);\n            result = this.handleNativeResponse(response, request, reqTimestamp);\n            this.browserStorage.setInteractionInProgress(false);\n            return [2 /*return*/, result];\n          case 3:\n            e_4 = _a.sent();\n            this.browserStorage.setInteractionInProgress(false);\n            throw e_4;\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Logout from native platform via browser extension\r\n   * @param request\r\n   */\n  NativeInteractionClient.prototype.logout = function () {\n    this.logger.trace(\"NativeInteractionClient - logout called.\");\n    return Promise.reject(\"Logout not implemented yet\");\n  };\n  /**\r\n   * Transform response from native platform into AuthenticationResult object which will be returned to the end user\r\n   * @param response\r\n   * @param request\r\n   * @param reqTimestamp\r\n   */\n  NativeInteractionClient.prototype.handleNativeResponse = function (response, request, reqTimestamp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var authority, idTokenObj, homeAccountIdentifier, accountEntity, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - handleNativeResponse called.\");\n            if (response.account.id !== request.accountId) {\n              // User switch in native broker prompt is not supported. All users must first sign in through web flow to ensure server state is in sync\n              throw NativeAuthError.createUserSwitchError();\n            }\n            return [4 /*yield*/, this.getDiscoveredAuthority(request.authority)];\n          case 1:\n            authority = _a.sent();\n            idTokenObj = this.createIdTokenObj(response);\n            homeAccountIdentifier = this.createHomeAccountIdentifier(response, idTokenObj);\n            accountEntity = AccountEntity.createAccount({\n              homeAccountId: homeAccountIdentifier,\n              idTokenClaims: idTokenObj.claims,\n              clientInfo: response.client_info,\n              nativeAccountId: response.account.id\n            }, authority);\n            return [4 /*yield*/, this.generateAuthenticationResult(response, request, idTokenObj, accountEntity, authority.canonicalAuthority, reqTimestamp)];\n          case 2:\n            result = _a.sent();\n            // cache accounts and tokens in the appropriate storage\n            this.cacheAccount(accountEntity);\n            this.cacheNativeTokens(response, request, homeAccountIdentifier, idTokenObj, result.accessToken, result.tenantId, reqTimestamp);\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  /**\r\n   * Create an idToken Object (not entity)\r\n   * @param response\r\n   * @returns\r\n   */\n  NativeInteractionClient.prototype.createIdTokenObj = function (response) {\n    return new AuthToken(response.id_token || Constants.EMPTY_STRING, this.browserCrypto);\n  };\n  /**\r\n   * creates an homeAccountIdentifier for the account\r\n   * @param response\r\n   * @param idTokenObj\r\n   * @returns\r\n   */\n  NativeInteractionClient.prototype.createHomeAccountIdentifier = function (response, idTokenObj) {\n    // Save account in browser storage\n    var homeAccountIdentifier = AccountEntity.generateHomeAccountId(response.client_info || Constants.EMPTY_STRING, AuthorityType.Default, this.logger, this.browserCrypto, idTokenObj.claims);\n    return homeAccountIdentifier;\n  };\n  /**\r\n   * Helper to generate scopes\r\n   * @param response\r\n   * @param request\r\n   * @returns\r\n   */\n  NativeInteractionClient.prototype.generateScopes = function (response, request) {\n    return response.scope ? ScopeSet.fromString(response.scope) : ScopeSet.fromString(request.scope);\n  };\n  /**\r\n   * If PoP token is requesred, records the PoP token if returned from the WAM, else generates one in the browser\r\n   * @param request\r\n   * @param response\r\n   */\n  NativeInteractionClient.prototype.generatePopAccessToken = function (response, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var popTokenGenerator, shrParameters;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(request.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 2];\n            /**\r\n             * This code prioritizes SHR returned from the native layer. In case of error/SHR not calculated from WAM and the AT\r\n             * is still received, SHR is calculated locally\r\n             */\n            // Check if native layer returned an SHR token\n            if (response.shr) {\n              this.logger.trace(\"handleNativeServerResponse: SHR is enabled in native layer\");\n              return [2 /*return*/, response.shr];\n            }\n            popTokenGenerator = new PopTokenGenerator(this.browserCrypto);\n            shrParameters = {\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              shrNonce: request.shrNonce\n            };\n            /**\r\n             * KeyID must be present in the native request from when the PoP key was generated in order for\r\n             * PopTokenGenerator to query the full key for signing\r\n             */\n            if (!request.keyId) {\n              throw ClientAuthError.createKeyIdMissingError();\n            }\n            return [4 /*yield*/, popTokenGenerator.signPopToken(response.access_token, request.keyId, shrParameters)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n          case 2:\n            return [2 /*return*/, response.access_token];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates authentication result\r\n   * @param response\r\n   * @param request\r\n   * @param idTokenObj\r\n   * @param accountEntity\r\n   * @param authority\r\n   * @param reqTimestamp\r\n   * @returns\r\n   */\n  NativeInteractionClient.prototype.generateAuthenticationResult = function (response, request, idTokenObj, accountEntity, authority, reqTimestamp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var mats, responseScopes, accountProperties, uid, tid, responseAccessToken, tokenType, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            mats = this.addTelemetryFromNativeResponse(response);\n            responseScopes = response.scope ? ScopeSet.fromString(response.scope) : ScopeSet.fromString(request.scope);\n            accountProperties = response.account.properties || {};\n            uid = accountProperties[\"UID\"] || idTokenObj.claims.oid || idTokenObj.claims.sub || Constants.EMPTY_STRING;\n            tid = accountProperties[\"TenantId\"] || idTokenObj.claims.tid || Constants.EMPTY_STRING;\n            return [4 /*yield*/, this.generatePopAccessToken(response, request)];\n          case 1:\n            responseAccessToken = _a.sent();\n            tokenType = request.tokenType === AuthenticationScheme.POP ? AuthenticationScheme.POP : AuthenticationScheme.BEARER;\n            result = {\n              authority: authority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes.asArray(),\n              account: accountEntity.getAccountInfo(),\n              idToken: response.id_token,\n              idTokenClaims: idTokenObj.claims,\n              accessToken: responseAccessToken,\n              fromCache: mats ? this.isResponseFromCache(mats) : false,\n              expiresOn: new Date(Number(reqTimestamp + response.expires_in) * 1000),\n              tokenType: tokenType,\n              correlationId: this.correlationId,\n              state: response.state,\n              fromNativeBroker: true\n            };\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  /**\r\n   * cache the account entity in browser storage\r\n   * @param accountEntity\r\n   */\n  NativeInteractionClient.prototype.cacheAccount = function (accountEntity) {\n    var _this = this;\n    // Store the account info and hence `nativeAccountId` in browser cache\n    this.browserStorage.setAccount(accountEntity);\n    // Remove any existing cached tokens for this account in browser storage\n    this.browserStorage.removeAccountContext(accountEntity).catch(function (e) {\n      _this.logger.error(\"Error occurred while removing account context from browser storage. \" + e);\n    });\n  };\n  /**\r\n   * Stores the access_token and id_token in inmemory storage\r\n   * @param response\r\n   * @param request\r\n   * @param homeAccountIdentifier\r\n   * @param idTokenObj\r\n   * @param responseAccessToken\r\n   * @param tenantId\r\n   * @param reqTimestamp\r\n   */\n  NativeInteractionClient.prototype.cacheNativeTokens = function (response, request, homeAccountIdentifier, idTokenObj, responseAccessToken, tenantId, reqTimestamp) {\n    var cachedIdToken = IdTokenEntity.createIdTokenEntity(homeAccountIdentifier, request.authority, response.id_token || Constants.EMPTY_STRING, request.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\n    // cache accessToken in inmemory storage\n    var expiresIn = request.tokenType === AuthenticationScheme.POP ? Constants.SHR_NONCE_VALIDITY : (typeof response.expires_in === \"string\" ? parseInt(response.expires_in, 10) : response.expires_in) || 0;\n    var tokenExpirationSeconds = reqTimestamp + expiresIn;\n    var responseScopes = this.generateScopes(response, request);\n    var cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(homeAccountIdentifier, request.authority, responseAccessToken, request.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : tenantId, responseScopes.printScopes(), tokenExpirationSeconds, 0, this.browserCrypto);\n    var nativeCacheRecord = new CacheRecord(undefined, cachedIdToken, cachedAccessToken);\n    this.nativeStorageManager.saveCacheRecord(nativeCacheRecord);\n  };\n  NativeInteractionClient.prototype.addTelemetryFromNativeResponse = function (response) {\n    var mats = this.getMATSFromResponse(response);\n    if (!mats) {\n      return null;\n    }\n    this.performanceClient.addStaticFields({\n      extensionId: this.nativeMessageHandler.getExtensionId(),\n      extensionVersion: this.nativeMessageHandler.getExtensionVersion(),\n      matsBrokerVersion: mats.broker_version,\n      matsAccountJoinOnStart: mats.account_join_on_start,\n      matsAccountJoinOnEnd: mats.account_join_on_end,\n      matsDeviceJoin: mats.device_join,\n      matsPromptBehavior: mats.prompt_behavior,\n      matsApiErrorCode: mats.api_error_code,\n      matsUiVisible: mats.ui_visible,\n      matsSilentCode: mats.silent_code,\n      matsSilentBiSubCode: mats.silent_bi_sub_code,\n      matsSilentMessage: mats.silent_message,\n      matsSilentStatus: mats.silent_status,\n      matsHttpStatus: mats.http_status,\n      matsHttpEventCount: mats.http_event_count\n    }, this.correlationId);\n    return mats;\n  };\n  /**\r\n   * Validates native platform response before processing\r\n   * @param response\r\n   */\n  NativeInteractionClient.prototype.validateNativeResponse = function (response) {\n    if (response.hasOwnProperty(\"access_token\") && response.hasOwnProperty(\"id_token\") && response.hasOwnProperty(\"client_info\") && response.hasOwnProperty(\"account\") && response.hasOwnProperty(\"scope\") && response.hasOwnProperty(\"expires_in\")) {\n      return response;\n    } else {\n      throw NativeAuthError.createUnexpectedError(\"Response missing expected properties.\");\n    }\n  };\n  /**\r\n   * Gets MATS telemetry from native response\r\n   * @param response\r\n   * @returns\r\n   */\n  NativeInteractionClient.prototype.getMATSFromResponse = function (response) {\n    if (response.properties.MATS) {\n      try {\n        return JSON.parse(response.properties.MATS);\n      } catch (e) {\n        this.logger.error(\"NativeInteractionClient - Error parsing MATS telemetry, returning null instead\");\n      }\n    }\n    return null;\n  };\n  /**\r\n   * Returns whether or not response came from native cache\r\n   * @param response\r\n   * @returns\r\n   */\n  NativeInteractionClient.prototype.isResponseFromCache = function (mats) {\n    if (typeof mats.is_cached === \"undefined\") {\n      this.logger.verbose(\"NativeInteractionClient - MATS telemetry does not contain field indicating if response was served from cache. Returning false.\");\n      return false;\n    }\n    return !!mats.is_cached;\n  };\n  /**\r\n   * Translates developer provided request object into NativeRequest object\r\n   * @param request\r\n   */\n  NativeInteractionClient.prototype.initializeNativeRequest = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var authority, canonicalAuthority, scopes, remainingProperties, scopeSet, getPrompt, validatedRequest, shrParameters, popTokenGenerator, reqCnfData;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - initializeNativeRequest called\");\n            authority = request.authority || this.config.auth.authority;\n            if (!request.account) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.validateRequestAuthority(authority, request.account)];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            canonicalAuthority = new UrlString(authority);\n            canonicalAuthority.validateAsUri();\n            scopes = request.scopes, remainingProperties = __rest(request, [\"scopes\"]);\n            scopeSet = new ScopeSet(scopes || []);\n            scopeSet.appendScopes(OIDC_DEFAULT_SCOPES);\n            getPrompt = function () {\n              // If request is silent, prompt is always none\n              switch (_this.apiId) {\n                case ApiId.ssoSilent:\n                case ApiId.acquireTokenSilent_silentFlow:\n                  _this.logger.trace(\"initializeNativeRequest: silent request sets prompt to none\");\n                  return PromptValue.NONE;\n              }\n              // Prompt not provided, request may proceed and native broker decides if it needs to prompt\n              if (!request.prompt) {\n                _this.logger.trace(\"initializeNativeRequest: prompt was not provided\");\n                return undefined;\n              }\n              // If request is interactive, check if prompt provided is allowed to go directly to native broker\n              switch (request.prompt) {\n                case PromptValue.NONE:\n                case PromptValue.CONSENT:\n                case PromptValue.LOGIN:\n                  _this.logger.trace(\"initializeNativeRequest: prompt is compatible with native flow\");\n                  return request.prompt;\n                default:\n                  _this.logger.trace(\"initializeNativeRequest: prompt = \" + request.prompt + \" is not compatible with native flow\");\n                  throw BrowserAuthError.createNativePromptParameterNotSupportedError();\n              }\n            };\n            validatedRequest = __assign(__assign({}, remainingProperties), {\n              accountId: this.accountId,\n              clientId: this.config.auth.clientId,\n              authority: canonicalAuthority.urlString,\n              scope: scopeSet.printScopes(),\n              redirectUri: this.getRedirectUri(request.redirectUri),\n              prompt: getPrompt(),\n              correlationId: this.correlationId,\n              tokenType: request.authenticationScheme,\n              windowTitleSubstring: document.title,\n              extraParameters: __assign(__assign(__assign({}, request.extraQueryParameters), request.tokenQueryParameters), {\n                telemetry: NativeConstants.MATS_TELEMETRY\n              }),\n              extendedExpiryToken: false // Make this configurable?\n            });\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3 /*break*/, 4];\n            shrParameters = {\n              resourceRequestUri: request.resourceRequestUri,\n              resourceRequestMethod: request.resourceRequestMethod,\n              shrClaims: request.shrClaims,\n              shrNonce: request.shrNonce\n            };\n            popTokenGenerator = new PopTokenGenerator(this.browserCrypto);\n            return [4 /*yield*/, popTokenGenerator.generateCnf(shrParameters)];\n          case 3:\n            reqCnfData = _a.sent();\n            // to reduce the URL length, it is recommended to send the short form of the req_cnf \n            validatedRequest.reqCnf = reqCnfData.reqCnfString;\n            validatedRequest.keyId = reqCnfData.kid;\n            _a.label = 4;\n          case 4:\n            return [2 /*return*/, validatedRequest];\n        }\n      });\n    });\n  };\n  return NativeInteractionClient;\n}(BaseInteractionClient);\nexport { NativeInteractionClient };\n//# sourceMappingURL=NativeInteractionClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}