{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { OIDC_DEFAULT_SCOPES, StringUtils, UrlString, Constants, AuthError, ThrottlingUtils, ProtocolUtils, PerformanceEvents } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.js';\nimport { EventType } from '../event/EventType.js';\nimport { BrowserConstants, InteractionType, ApiId } from '../utils/BrowserConstants.js';\nimport { BrowserUtils } from '../utils/BrowserUtils.js';\nimport { NativeInteractionClient } from './NativeInteractionClient.js';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { InteractionHandler } from '../interaction_handler/InteractionHandler.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar PopupClient = /** @class */function (_super) {\n  __extends(PopupClient, _super);\n  function PopupClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n    var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId) || this;\n    // Properly sets this reference for the unload event.\n    _this.unloadWindow = _this.unloadWindow.bind(_this);\n    _this.nativeStorage = nativeStorageImpl;\n    return _this;\n  }\n  /**\r\n   * Acquires tokens by opening a popup window to the /authorize endpoint of the authority\r\n   * @param request\r\n   */\n  PopupClient.prototype.acquireToken = function (request) {\n    try {\n      var popupName = this.generatePopupName(request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority);\n      var popupWindowAttributes = request.popupWindowAttributes || {};\n      // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n      if (this.config.system.asyncPopups) {\n        this.logger.verbose(\"asyncPopups set to true, acquiring token\");\n        // Passes on popup position and dimensions if in request\n        return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes);\n      } else {\n        // asyncPopups flag is set to false. Opens popup before acquiring token.\n        this.logger.verbose(\"asyncPopup set to false, opening popup before acquiring token\");\n        var popup = this.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes);\n        return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  /**\r\n   * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\r\n   * @param logoutRequest\r\n   */\n  PopupClient.prototype.logout = function (logoutRequest) {\n    try {\n      this.logger.verbose(\"logoutPopup called\");\n      var validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n      var popupName = this.generateLogoutPopupName(validLogoutRequest);\n      var authority = logoutRequest && logoutRequest.authority;\n      var mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;\n      var popupWindowAttributes = (logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.popupWindowAttributes) || {};\n      // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n      if (this.config.system.asyncPopups) {\n        this.logger.verbose(\"asyncPopups set to true\");\n        // Passes on popup position and dimensions if in request\n        return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, undefined, mainWindowRedirectUri);\n      } else {\n        // asyncPopups flag is set to false. Opens popup before logging out.\n        this.logger.verbose(\"asyncPopup set to false, opening popup\");\n        var popup = this.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes);\n        return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, popup, mainWindowRedirectUri);\n      }\n    } catch (e) {\n      // Since this function is synchronous we need to reject\n      return Promise.reject(e);\n    }\n  };\n  /**\r\n   * Helper which obtains an access_token for your API via opening a popup window in the user's browser\r\n   * @param validRequest\r\n   * @param popupName\r\n   * @param popup\r\n   * @param popupWindowAttributes\r\n   *\r\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n   */\n  PopupClient.prototype.acquireTokenPopupAsync = function (request, popupName, popupWindowAttributes, popup) {\n    return __awaiter(this, void 0, void 0, function () {\n      var serverTelemetryManager, validRequest, authCodeRequest, authClient, isNativeBroker, fetchNativeAccountIdMeasurement, navigateUrl, interactionHandler, popupParameters, popupWindow, hash, serverParams, state_1, nativeInteractionClient, userRequestState, result, e_1;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"acquireTokenPopupAsync called\");\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup);\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);\n            return [4 /*yield*/, this.initializeAuthorizationRequest(request, InteractionType.Popup)];\n          case 1:\n            validRequest = _a.sent();\n            this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || Constants.EMPTY_STRING, validRequest.account || null);\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 8,, 9]);\n            // Create auth code request and generate PKCE params\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);\n            return [4 /*yield*/, this.initializeAuthorizationCodeRequest(validRequest)];\n          case 3:\n            authCodeRequest = _a.sent();\n            // Initialize the client\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, request.correlationId);\n            return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions)];\n          case 4:\n            authClient = _a.sent();\n            this.logger.verbose(\"Auth code client created\");\n            isNativeBroker = NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme);\n            fetchNativeAccountIdMeasurement = void 0;\n            if (isNativeBroker) {\n              fetchNativeAccountIdMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.FetchAccountIdWithNativeBroker, request.correlationId);\n            }\n            return [4 /*yield*/, authClient.getAuthCodeUrl(__assign(__assign({}, validRequest), {\n              nativeBroker: isNativeBroker\n            }))];\n          case 5:\n            navigateUrl = _a.sent();\n            interactionHandler = new InteractionHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.performanceClient);\n            popupParameters = {\n              popup: popup,\n              popupName: popupName,\n              popupWindowAttributes: popupWindowAttributes\n            };\n            popupWindow = this.initiateAuthRequest(navigateUrl, popupParameters);\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n              popupWindow: popupWindow\n            }, null);\n            return [4 /*yield*/, this.monitorPopupForHash(popupWindow)];\n          case 6:\n            hash = _a.sent();\n            serverParams = UrlString.getDeserializedHash(hash);\n            state_1 = this.validateAndExtractStateFromHash(serverParams, InteractionType.Popup, validRequest.correlationId);\n            // Remove throttle if it exists\n            ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, authCodeRequest);\n            if (serverParams.accountId) {\n              this.logger.verbose(\"Account id found in hash, calling WAM for token\");\n              // end measurement for server call with native brokering enabled\n              if (fetchNativeAccountIdMeasurement) {\n                fetchNativeAccountIdMeasurement.endMeasurement({\n                  success: true,\n                  isNativeBroker: true\n                });\n              }\n              if (!this.nativeMessageHandler) {\n                throw BrowserAuthError.createNativeConnectionNotEstablishedError();\n              }\n              nativeInteractionClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, serverParams.accountId, this.nativeStorage, validRequest.correlationId);\n              userRequestState = ProtocolUtils.parseRequestState(this.browserCrypto, state_1).userRequestState;\n              return [2 /*return*/, nativeInteractionClient.acquireToken(__assign(__assign({}, validRequest), {\n                state: userRequestState,\n                prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently\n              })).finally(function () {\n                _this.browserStorage.cleanRequestByState(state_1);\n              })];\n            }\n            return [4 /*yield*/, interactionHandler.handleCodeResponseFromHash(hash, state_1, authClient.authority, this.networkClient)];\n          case 7:\n            result = _a.sent();\n            return [2 /*return*/, result];\n          case 8:\n            e_1 = _a.sent();\n            if (popup) {\n              // Close the synchronous popup if an error is thrown before the window unload event is registered\n              popup.close();\n            }\n            if (e_1 instanceof AuthError) {\n              e_1.setCorrelationId(this.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e_1);\n            this.browserStorage.cleanRequestByState(validRequest.state);\n            throw e_1;\n          case 9:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @param validRequest\r\n   * @param popupName\r\n   * @param requestAuthority\r\n   * @param popup\r\n   * @param mainWindowRedirectUri\r\n   * @param popupWindowAttributes\r\n   */\n  PopupClient.prototype.logoutPopupAsync = function (validRequest, popupName, popupWindowAttributes, requestAuthority, popup, mainWindowRedirectUri) {\n    return __awaiter(this, void 0, void 0, function () {\n      var serverTelemetryManager, authClient, logoutUri, popupWindow, navigationOptions, absoluteUrl, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"logoutPopupAsync called\");\n            this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logoutPopup);\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 5,, 6]);\n            // Clear cache on logout\n            return [4 /*yield*/, this.clearCacheOnLogout(validRequest.account)];\n          case 2:\n            // Clear cache on logout\n            _a.sent();\n            // Initialize the client\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, validRequest.correlationId);\n            return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, requestAuthority)];\n          case 3:\n            authClient = _a.sent();\n            this.logger.verbose(\"Auth code client created\");\n            logoutUri = authClient.getLogoutUri(validRequest);\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n            popupWindow = this.openPopup(logoutUri, {\n              popupName: popupName,\n              popupWindowAttributes: popupWindowAttributes,\n              popup: popup\n            });\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n              popupWindow: popupWindow\n            }, null);\n            return [4 /*yield*/, this.waitForLogoutPopup(popupWindow)];\n          case 4:\n            _a.sent();\n            if (mainWindowRedirectUri) {\n              navigationOptions = {\n                apiId: ApiId.logoutPopup,\n                timeout: this.config.system.redirectNavigationTimeout,\n                noHistory: false\n              };\n              absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\n              this.logger.verbose(\"Redirecting main window to url specified in the request\");\n              this.logger.verbosePii(\"Redirecting main window to: \" + absoluteUrl);\n              this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n            } else {\n              this.logger.verbose(\"No main window navigation requested\");\n            }\n            return [3 /*break*/, 6];\n          case 5:\n            e_2 = _a.sent();\n            if (popup) {\n              // Close the synchronous popup if an error is thrown before the window unload event is registered\n              popup.close();\n            }\n            if (e_2 instanceof AuthError) {\n              e_2.setCorrelationId(this.correlationId);\n            }\n            this.browserStorage.setInteractionInProgress(false);\n            this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e_2);\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n            serverTelemetryManager.cacheFailedRequest(e_2);\n            throw e_2;\n          case 6:\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Opens a popup window with given request Url.\r\n   * @param requestUrl\r\n   */\n  PopupClient.prototype.initiateAuthRequest = function (requestUrl, params) {\n    // Check that request url is not empty.\n    if (!StringUtils.isEmpty(requestUrl)) {\n      this.logger.infoPii(\"Navigate to: \" + requestUrl);\n      // Open the popup window to requestUrl.\n      return this.openPopup(requestUrl, params);\n    } else {\n      // Throw error if request URL is empty.\n      this.logger.error(\"Navigate url is empty\");\n      throw BrowserAuthError.createEmptyNavigationUriError();\n    }\n  };\n  /**\r\n   * Monitors a window until it loads a url with the same origin.\r\n   * @param popupWindow - window that is being monitored\r\n   * @param timeout - timeout for processing hash once popup is redirected back to application\r\n   */\n  PopupClient.prototype.monitorPopupForHash = function (popupWindow) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      /*\r\n       * Polling for popups needs to be tick-based,\r\n       * since a non-trivial amount of time can be spent on interaction (which should not count against the timeout).\r\n       */\n      var maxTicks = _this.config.system.windowHashTimeout / _this.config.system.pollIntervalMilliseconds;\n      var ticks = 0;\n      _this.logger.verbose(\"PopupHandler.monitorPopupForHash - polling started\");\n      var intervalId = setInterval(function () {\n        // Window is closed\n        if (popupWindow.closed) {\n          _this.logger.error(\"PopupHandler.monitorPopupForHash - window closed\");\n          _this.cleanPopup();\n          clearInterval(intervalId);\n          reject(BrowserAuthError.createUserCancelledError());\n          return;\n        }\n        var href = Constants.EMPTY_STRING;\n        var hash = Constants.EMPTY_STRING;\n        try {\n          /*\r\n           * Will throw if cross origin,\r\n           * which should be caught and ignored\r\n           * since we need the interval to keep running while on STS UI.\r\n           */\n          href = popupWindow.location.href;\n          hash = popupWindow.location.hash;\n        } catch (e) {}\n        // Don't process blank pages or cross domain\n        if (StringUtils.isEmpty(href) || href === \"about:blank\") {\n          return;\n        }\n        _this.logger.verbose(\"PopupHandler.monitorPopupForHash - popup window is on same origin as caller\");\n        /*\r\n         * Only run clock when we are on same domain for popups\r\n         * as popup operations can take a long time.\r\n         */\n        ticks++;\n        if (hash) {\n          _this.logger.verbose(\"PopupHandler.monitorPopupForHash - found hash in url\");\n          clearInterval(intervalId);\n          _this.cleanPopup(popupWindow);\n          if (UrlString.hashContainsKnownProperties(hash)) {\n            _this.logger.verbose(\"PopupHandler.monitorPopupForHash - hash contains known properties, returning.\");\n            resolve(hash);\n          } else {\n            _this.logger.error(\"PopupHandler.monitorPopupForHash - found hash in url but it does not contain known properties. Check that your router is not changing the hash prematurely.\");\n            _this.logger.errorPii(\"PopupHandler.monitorPopupForHash - hash found: \" + hash);\n            reject(BrowserAuthError.createHashDoesNotContainKnownPropertiesError());\n          }\n        } else if (ticks > maxTicks) {\n          _this.logger.error(\"PopupHandler.monitorPopupForHash - unable to find hash in url, timing out\");\n          clearInterval(intervalId);\n          reject(BrowserAuthError.createMonitorPopupTimeoutError());\n        }\n      }, _this.config.system.pollIntervalMilliseconds);\n    });\n  };\n  /**\r\n   * Waits for user interaction in logout popup window\r\n   * @param popupWindow\r\n   * @returns\r\n   */\n  PopupClient.prototype.waitForLogoutPopup = function (popupWindow) {\n    var _this = this;\n    return new Promise(function (resolve) {\n      _this.logger.verbose(\"PopupHandler.waitForLogoutPopup - polling started\");\n      var intervalId = setInterval(function () {\n        // Window is closed\n        if (popupWindow.closed) {\n          _this.logger.error(\"PopupHandler.waitForLogoutPopup - window closed\");\n          _this.cleanPopup();\n          clearInterval(intervalId);\n          resolve();\n        }\n        var href = Constants.EMPTY_STRING;\n        try {\n          /*\r\n           * Will throw if cross origin,\r\n           * which should be caught and ignored\r\n           * since we need the interval to keep running while on STS UI.\r\n           */\n          href = popupWindow.location.href;\n        } catch (e) {}\n        // Don't process blank pages or cross domain\n        if (StringUtils.isEmpty(href) || href === \"about:blank\") {\n          return;\n        }\n        _this.logger.verbose(\"PopupHandler.waitForLogoutPopup - popup window is on same origin as caller, closing.\");\n        clearInterval(intervalId);\n        _this.cleanPopup(popupWindow);\n        resolve();\n      }, _this.config.system.pollIntervalMilliseconds);\n    });\n  };\n  /**\r\n   * @hidden\r\n   *\r\n   * Configures popup window for login.\r\n   *\r\n   * @param urlNavigate\r\n   * @param title\r\n   * @param popUpWidth\r\n   * @param popUpHeight\r\n   * @param popupWindowAttributes\r\n   * @ignore\r\n   * @hidden\r\n   */\n  PopupClient.prototype.openPopup = function (urlNavigate, popupParams) {\n    try {\n      var popupWindow = void 0;\n      // Popup window passed in, setting url to navigate to\n      if (popupParams.popup) {\n        popupWindow = popupParams.popup;\n        this.logger.verbosePii(\"Navigating popup window to: \" + urlNavigate);\n        popupWindow.location.assign(urlNavigate);\n      } else if (typeof popupParams.popup === \"undefined\") {\n        // Popup will be undefined if it was not passed in\n        this.logger.verbosePii(\"Opening popup window to: \" + urlNavigate);\n        popupWindow = this.openSizedPopup(urlNavigate, popupParams.popupName, popupParams.popupWindowAttributes);\n      }\n      // Popup will be null if popups are blocked\n      if (!popupWindow) {\n        throw BrowserAuthError.createEmptyWindowCreatedError();\n      }\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n      this.currentWindow = popupWindow;\n      window.addEventListener(\"beforeunload\", this.unloadWindow);\n      return popupWindow;\n    } catch (e) {\n      this.logger.error(\"error opening popup \" + e.message);\n      this.browserStorage.setInteractionInProgress(false);\n      throw BrowserAuthError.createPopupWindowError(e.toString());\n    }\n  };\n  /**\r\n   * Helper function to set popup window dimensions and position\r\n   * @param urlNavigate\r\n   * @param popupName\r\n   * @param popupWindowAttributes\r\n   * @returns\r\n   */\n  PopupClient.prototype.openSizedPopup = function (urlNavigate, popupName, popupWindowAttributes) {\n    var _a, _b, _c, _d;\n    /**\r\n     * adding winLeft and winTop to account for dual monitor\r\n     * using screenLeft and screenTop for IE8 and earlier\r\n     */\n    var winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n    var winTop = window.screenTop ? window.screenTop : window.screenY;\n    /**\r\n     * window.innerWidth displays browser window\"s height and width excluding toolbars\r\n     * using document.documentElement.clientWidth for IE8 and earlier\r\n     */\n    var winWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    var winHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n    var width = (_a = popupWindowAttributes.popupSize) === null || _a === void 0 ? void 0 : _a.width;\n    var height = (_b = popupWindowAttributes.popupSize) === null || _b === void 0 ? void 0 : _b.height;\n    var top = (_c = popupWindowAttributes.popupPosition) === null || _c === void 0 ? void 0 : _c.top;\n    var left = (_d = popupWindowAttributes.popupPosition) === null || _d === void 0 ? void 0 : _d.left;\n    if (!width || width < 0 || width > winWidth) {\n      this.logger.verbose(\"Default popup window width used. Window width not configured or invalid.\");\n      width = BrowserConstants.POPUP_WIDTH;\n    }\n    if (!height || height < 0 || height > winHeight) {\n      this.logger.verbose(\"Default popup window height used. Window height not configured or invalid.\");\n      height = BrowserConstants.POPUP_HEIGHT;\n    }\n    if (!top || top < 0 || top > winHeight) {\n      this.logger.verbose(\"Default popup window top position used. Window top not configured or invalid.\");\n      top = Math.max(0, winHeight / 2 - BrowserConstants.POPUP_HEIGHT / 2 + winTop);\n    }\n    if (!left || left < 0 || left > winWidth) {\n      this.logger.verbose(\"Default popup window left position used. Window left not configured or invalid.\");\n      left = Math.max(0, winWidth / 2 - BrowserConstants.POPUP_WIDTH / 2 + winLeft);\n    }\n    return window.open(urlNavigate, popupName, \"width=\" + width + \", height=\" + height + \", top=\" + top + \", left=\" + left + \", scrollbars=yes\");\n  };\n  /**\r\n   * Event callback to unload main window.\r\n   */\n  PopupClient.prototype.unloadWindow = function (e) {\n    this.browserStorage.cleanRequestByInteractionType(InteractionType.Popup);\n    if (this.currentWindow) {\n      this.currentWindow.close();\n    }\n    // Guarantees browser unload will happen, so no other errors will be thrown.\n    e.preventDefault();\n  };\n  /**\r\n   * Closes popup, removes any state vars created during popup calls.\r\n   * @param popupWindow\r\n   */\n  PopupClient.prototype.cleanPopup = function (popupWindow) {\n    if (popupWindow) {\n      // Close window.\n      popupWindow.close();\n    }\n    // Remove window unload function\n    window.removeEventListener(\"beforeunload\", this.unloadWindow);\n    // Interaction is completed - remove interaction status.\n    this.browserStorage.setInteractionInProgress(false);\n  };\n  /**\r\n   * Generates the name for the popup based on the client id and request\r\n   * @param clientId\r\n   * @param request\r\n   */\n  PopupClient.prototype.generatePopupName = function (scopes, authority) {\n    return BrowserConstants.POPUP_NAME_PREFIX + \".\" + this.config.auth.clientId + \".\" + scopes.join(\"-\") + \".\" + authority + \".\" + this.correlationId;\n  };\n  /**\r\n   * Generates the name for the popup based on the client id and request for logouts\r\n   * @param clientId\r\n   * @param request\r\n   */\n  PopupClient.prototype.generateLogoutPopupName = function (request) {\n    var homeAccountId = request.account && request.account.homeAccountId;\n    return BrowserConstants.POPUP_NAME_PREFIX + \".\" + this.config.auth.clientId + \".\" + homeAccountId + \".\" + this.correlationId;\n  };\n  return PopupClient;\n}(StandardInteractionClient);\nexport { PopupClient };\n//# sourceMappingURL=PopupClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}